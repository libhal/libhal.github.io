{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83c\udfe1 Home","text":"Welcome to libhal"},{"location":"#abstract","title":"Abstract","text":"<p>libhal exists to make hardware drivers \ud83d\ude9a portable, \ud83e\uddbe flexible, \ud83d\udce6 accessible, and \ud83c\udf70 easy to use. libhal seeks to provide a foundation for embedded drivers, allowing those drivers to be used across different processors, microcontrollers, systems, and devices.</p> <p>The design philosophy of libhal is to be:</p> <ol> <li>Portable &amp; Cross Platform</li> <li>General</li> <li>Fast &amp; Compact</li> <li>Minimalist</li> <li>Safe, Reliable, Tested &amp; Testable</li> <li>Build Time Conscious</li> <li>OS Agnostic</li> </ol>"},{"location":"#the-basics","title":"The Basics","text":"<p>libhal, at its core, is simply a set of interfaces that correspond to hardware devices and peripherals. These interfaces use runtime polymorphism in order to decouple application logic from driver implementation details. This decoupling enables applications to run on any platform device that has the necessary components available.</p> <p>A quick example is a blinker program. You want to turn on and off an LED at a fixed interval. This would require something along the lines of a GPIO and a timer to tell time. In libhal we can use drivers that implement the <code>hal::output_pin</code> and <code>hal::steady_clock</code> interfaces. Such code would look like the following and would support the <code>lpc4078</code>, <code>stm32f103c8</code>, and devices supported by the <code>libhal-micromod</code> project.</p> include/resource_list.hppmain.cppplatform/stm32f103c8.hppplatform/micromod.hppplatform/lpc4078.hpp <pre><code>#pragma once\n\n#include &lt;libhal/functional.hpp&gt;\n#include &lt;libhal/output_pin.hpp&gt;\n#include &lt;libhal/serial.hpp&gt;\n#include &lt;libhal/steady_clock.hpp&gt;\n\nstruct resource_list\n{\n  hal::callback&lt;void()&gt; reset;\n  hal::output_pin* status_led;\n  hal::serial* console;\n  hal::steady_clock* clock;\n};\n\nresource_list initialize_platform();\n</code></pre> <pre><code>#include &lt;libhal-util/steady_clock.hpp&gt;\n\n#include &lt;resource_list.hpp&gt;\n\nresource_list resources{};\n\nint main()\n{\n  try {\n    resources = initialize_platform();\n  } catch (...) {\n    while (true) {\n      // halt here and wait for a debugger to connect\n      continue;\n    }\n  }\n\n  hal::output_pin&amp; led = resources.led;\n  hal::steady_clock&amp; clock = resources.clock;\n\n  for (int i = 0; i &lt; 10; i++) {\n    // Turn on LED\n    led.level(true);\n    hal::delay(clock, 500ms);\n    // Turn off LED\n    led.level(false);\n    hal::delay(clock, 500ms);\n  }\n}\n</code></pre> <pre><code>#include &lt;libhal-arm-mcu/dwt_counter.hpp&gt;\n#include &lt;libhal-arm-mcu/stm32f1/clock.hpp&gt;\n#include &lt;libhal-arm-mcu/stm32f1/constants.hpp&gt;\n#include &lt;libhal-arm-mcu/stm32f1/output_pin.hpp&gt;\n#include &lt;libhal-arm-mcu/stm32f1/uart.hpp&gt;\n#include &lt;libhal-arm-mcu/system_control.hpp&gt;\n\n#include &lt;resource_list.hpp&gt;\n\nresource_list initialize_platform()\n{\n  using namespace hal::literals;\n\n  // Set the MCU to the maximum clock speed\n  hal::stm32f1::maximum_speed_using_internal_oscillator();\n\n  static hal::cortex_m::dwt_counter counter(\n    hal::stm32f1::frequency(hal::stm32f1::peripheral::cpu));\n\n  static hal::stm32f1::uart uart1(hal::port&lt;1&gt;,\n                                  hal::buffer&lt;128&gt;,\n                                  hal::serial::settings{\n                                    .baud_rate = 115200,\n                                  });\n\n  static hal::stm32f1::output_pin led('C', 13);\n\n  return {\n    .reset = +[]() { hal::cortex_m::reset(); },\n    .status_led = &amp;led,\n    .console = &amp;uart1,\n    .clock = &amp;counter,\n  };\n}\n</code></pre> <pre><code>#include &lt;libhal-micromod/micromod.hpp&gt;\n\n#include &lt;resource_list.hpp&gt;\n\nresource_list initialize_platform()\n{\n  using namespace hal::literals;\n\n  hal::micromod::v1::initialize_platform();\n\n  return {\n    .reset = +[]() { hal::micromod::v1::reset(); },\n    .status_led = &amp;hal::micromod::v1::led(),\n    .console = &amp;hal::micromod::v1::console(hal::buffer&lt;128&gt;),\n    .clock = &amp;hal::micromod::v1::uptime_clock(),\n  };\n}\n</code></pre> <pre><code>#include &lt;libhal-arm-mcu/dwt_counter.hpp&gt;\n#include &lt;libhal-arm-mcu/lpc40/clock.hpp&gt;\n#include &lt;libhal-arm-mcu/lpc40/constants.hpp&gt;\n#include &lt;libhal-arm-mcu/lpc40/output_pin.hpp&gt;\n#include &lt;libhal-arm-mcu/lpc40/uart.hpp&gt;\n#include &lt;libhal-arm-mcu/startup.hpp&gt;\n#include &lt;libhal-arm-mcu/system_control.hpp&gt;\n\n#include &lt;resource_list.hpp&gt;\n\nresource_list initialize_platform()\n{\n  using namespace hal::literals;\n\n  // Set the MCU to the maximum clock speed\n  hal::lpc40::maximum(12.0_MHz);\n\n  auto cpu_frequency = hal::lpc40::get_frequency(hal::lpc40::peripheral::cpu);\n  static hal::cortex_m::dwt_counter counter(cpu_frequency);\n\n  static std::array&lt;hal::byte, 64&gt; receive_buffer{};\n  static hal::lpc40::uart uart0(0,\n                                receive_buffer,\n                                hal::serial::settings{\n                                  .baud_rate = 115200,\n                                });\n\n  static hal::lpc40::output_pin led(1, 10);\n\n  return {\n    .reset = +[]() { hal::cortex_m::reset(); },\n    .status_led = &amp;led,\n    .console = &amp;uart0,\n    .clock = &amp;counter,\n  };\n}\n</code></pre>"},{"location":"#support","title":"Support","text":"<ul> <li>libhal discord server (preferred)</li> <li>GitHub issues</li> <li>Cpplang Slack #embedded channel</li> </ul>"},{"location":"#distribution","title":"Distribution","text":"<ul> <li>Conan package manager</li> <li>Source code is hosted on GitHub</li> </ul>"},{"location":"#sponsorships","title":"Sponsorships","text":"<p>We are proud to be sponsored by JFrog. JFrog generously provides us with free artifact management, security, and CI/CD tools, allowing us to focus on the success of our project.</p> <p>We are grateful for their support and contribution to the open source community. Thank you, JFrog!</p> <p>For more information about JFrog's community initiatives, visit their Giving Back page.</p>"},{"location":"getting_started/","title":"\ud83d\ude80 Getting Started","text":""},{"location":"getting_started/#install-prerequisites","title":"\ud83e\uddf0 Install Prerequisites","text":"<p>What you will need in order to get started with libhal.</p> <ul> <li><code>python</code>: 3.10 or above</li> <li><code>conan</code>: 2.2.0 or above</li> <li><code>llvm</code>: 17</li> <li><code>make</code>: (CMake is downloaded via conan and uses make to build)</li> <li><code>git</code> (only needs to be installed on Windows)</li> </ul> Ubuntu 20.04+MacOS XWindows <p>Install <code>llvm</code> toolchain &amp; APT repos:</p> <pre><code>wget https://apt.llvm.org/llvm.sh\nchmod +x llvm.sh\nsudo ./llvm.sh 17\n</code></pre> <p>Install LLVM's C++ standard library (this will use the llvm apt repos):</p> <pre><code>sudo apt install libc++-17-dev libc++abi-17-dev\n</code></pre> <p>Info</p> <p>If you are using 20.04 you will need to upgrade Python to 3.10:</p> <pre><code>sudo apt update\nsudo apt install software-properties-common -y\nsudo add-apt-repository ppa:deadsnakes/ppa\nsudo apt install Python3.10\n</code></pre> <p>Installing conan:</p> <pre><code>python3 -m pip install \"conan&gt;=2.2.2\"\n</code></pre> <p>Install Homebrew:</p> <pre><code>/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n</code></pre> <p>Install latest version of Python &amp;&amp; llvm:</p> <pre><code>brew install python\nbrew install llvm@17\n</code></pre> <p>Install conan:</p> <pre><code>python3 -m pip install \"conan&gt;=2.2.2\"\n</code></pre> <p>Make <code>clang-tidy</code> available on the command line:</p> <pre><code>sudo ln -s $(brew --prefix llvm)/bin/clang-tidy /usr/local/bin/\n</code></pre> <p>Install Rosetta (only required for M1 macs):</p> <pre><code>/usr/sbin/softwareupdate --install-rosetta --agree-to-license\n</code></pre> <p>We recommend using the <code>choco</code> package manager for windows as it allows easy installation of tools via the command line.</p> <p>To install <code>choco</code>, open PowerShell as an administrator and run the following command:</p> <pre><code>Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))\n</code></pre> <p>Tip</p> <p>If the <code>choco</code> command doesn't work after running this script try closing and opening again PowerShell.</p> <p>When <code>choco</code> prompts you to run install scripts from the commands below enter <code>all</code> so it can install everything.</p> <p>Install <code>git</code> (must be in admin powershell):</p> <pre><code>choco install git\n</code></pre> <p>Install mingw to get mingw-make for Windows CMake (must be in admin powershell):</p> <pre><code>choco install mingw\n</code></pre> <p>Install <code>python</code> (must be in admin powershell):</p> <pre><code>choco install python --version=3.12.2\n</code></pre> <p>Install llvm (must be in admin powershell):</p> <pre><code>choco install llvm --version=17.0.6\n</code></pre> <p>Install conan (must be in admin powershell):</p> <pre><code>python -m pip install -U \"conan&gt;=2.2.2\"\n</code></pre> <p>There is no more installation required at this point.</p> <p>Close and reopen powershell as a normal user now.</p>"},{"location":"getting_started/#setting-up-conan","title":"\ud83d\udd27 Setting up Conan","text":"<p>Add the <code>libhal-trunk</code> repository to your system. This repository holds all of the libhal packages.</p> <pre><code>conan remote add libhal-trunk https://libhal.jfrog.io/artifactory/api/conan/trunk-conan\n</code></pre> <p>Next, install the libhal <code>settings_user.yml</code> which extends the architectures of conan's <code>settings.yml</code> file to include baremetal architectures. These additional architecture definitions are required for ALMOST ALL libhal applications.</p> <pre><code>conan config install -sf profiles/baremetal/v2 https://github.com/libhal/conan-config.git\n</code></pre> <p>Next, setup the host profile. Host profiles define the compiler, compiler version, standard library version, and many other settings used to configure how applications are built.</p> <p>First detect the default.</p> <pre><code>conan profile detect --force\n</code></pre> <p>Now install the profile for your particular OS and CPU architecture.</p> Intel LinuxARM64 LinuxM1 MacIntel MacIntel WindowsARM64 Windows <p>If your host machine is using an intel core processor as its CPU then you'll want to use this default configuration.</p> <pre><code>conan config install -sf profiles/x86_64/linux/ -tf profiles https://github.com/libhal/conan-config.git\n</code></pre> <p>It is less likely your host desktop is an ARM64. This section is mostly for building applications and tests on a Raspberry PI or other SBC. But if you do have a laptop powered by an ARM64 core, then this is the correct configuration for you.</p> <pre><code>conan config install -sf profiles/armv8/linux/ -tf profiles https://github.com/libhal/conan-config.git\n</code></pre> <p>If your Mac Book uses an M1 processor then you'll want to use this default configuration.</p> <pre><code>conan config install -sf profiles/armv8/mac/ -tf profiles https://github.com/libhal/conan-config.git\n</code></pre> <p>If your Mac Book uses an Intel processor then you'll want to use this default configuration.</p> <pre><code>conan config install -sf profiles/x86_64/mac/ -tf profiles https://github.com/libhal/conan-config.git\n</code></pre> <p>If your Windows machine uses an Intel processor then you'll want to use this default configuration.</p> <pre><code>conan config install -sf profiles/x86_64/windows/ -tf profiles https://github.com/libhal/conan-config.git\n</code></pre> <p>If you have a modern surface laptop with ARM64, then this may be the right choice for you (this profile is untested).</p> <pre><code>conan config install -sf profiles/armv8/windows/ -tf profiles https://github.com/libhal/conan-config.git\n</code></pre>"},{"location":"getting_started/#building-demos","title":"\ud83d\udee0\ufe0f Building Demos","text":"<p>Before start building demos, we have to consider on what device do we plan to run the demo on? ARM microcontrollers are quite common so lets use that as an example. Lets clone the <code>libhal-arm-mcu</code> repo.</p> <pre><code>git clone https://github.com/libhal/libhal-arm-mcu\ncd libhal-arm-mcu\n</code></pre> <p>The next lets install the device profiles. Device profiles instruct the build system, conan &amp; cmake, to build the binaries for your particular device. A few commonly used profiles are the <code>lpc4078</code> and <code>stm32f103c8</code> profiles. To make them available on your system run the following command:</p> <pre><code>conan config install -sf conan/profiles/v1 -tf profiles https://github.com/libhal/libhal-arm-mcu.git\n</code></pre> <p>The device profiles only has half of the information. The other half needed to build an application is the compiler profile. Compiler profiles are used to instruct the conan+cmake build system on the compiler to use for the build.</p> <pre><code>conan config install -sf conan/profiles/v1 -tf profiles https://github.com/libhal/arm-gnu-toolchain.git\n</code></pre> <p>Now we have everything we need to build our project. To build using conan you just need to run the following:</p> LPC4078STM32F103 <pre><code>conan build demos -pr lpc4078 -pr arm-gcc-12.3\n</code></pre> <pre><code>conan build demos -pr stm32f103c8 -pr arm-gcc-12.3\n</code></pre> <p>When you build for the <code>lpc4078</code> you should have a <code>uart.elf</code> and <code>blinker.elf</code> file in the <code>demos/build/lpc4078/MinSizeRel/</code> directory.</p> <p>When you build for the <code>stm32f103c8</code> you should have a <code>uart.elf</code> and <code>blinker.elf</code> file in the <code>demos/build/stm32f103c8/MinSizeRel/</code> directory.</p> <p>Error</p> <p>You can get this error if the arm gnu toolchain wasn't installed correctly and the cmake toolchain was already generated.</p> <pre><code>  The CMAKE_CXX_COMPILER:\n\n    /Users/user_name/.conan2/p/b/arm-ged7418b49387e/p/bin/bin/arm-none-eabi-g++\n\n  is not a full path to an existing compiler tool.\n</code></pre> <p>Fix this by deleting the <code>demos/build/</code> like so:</p> <pre><code>rm -r demos/build\n</code></pre>"},{"location":"getting_started/#uploading-demos-to-device","title":"\ud83d\udcbe Uploading Demos to Device","text":"<p>In order to complete this tutorial you'll one of these devices:</p> <ul> <li>LPC4078 MicroMod with SparkFun ATP board</li> <li>SJ2 Board</li> <li>STM32F103 MicroMod with SparkFun ATP board</li> <li>STM32 Blue Pill along with USB to serial adapter</li> </ul> LPC4078STM32F103 <p>Install the <code>nxpprog</code> flashing software for LPC devices:</p> <pre><code>python3 -m pip install nxpprog\n</code></pre> <p>Tip</p> <p>On Ubuntu 22.04 you will need to use the command <code>python3.10</code> because the default python is usually 3.8.</p> <pre><code>python3.10 -m pip install nxpprog\n</code></pre> <pre><code>nxpprog --control --binary demos/build/lpc4078/MinSizeRel/uart.elf.bin --device /dev/tty.usbserial-140\n</code></pre> <ul> <li>Replace <code>/dev/tty.usbserial-140</code> with the correct port   name of the device plugged into your computer via USB.</li> <li>Replace <code>uart.elf.bin</code> with any other application found in the   <code>demos/applications/</code> directory.</li> </ul> <p>Install the <code>stm32loader</code> flashing software for STM32 devices:</p> <pre><code>python3 -m pip install stm32loader\n</code></pre> <p>then</p> <pre><code>stm32loader -e -w -v -B -p /dev/tty.usbserial-10 demos/build/stm32f103c8/MinSizeRel/uart.elf.bin\n</code></pre> <p>Replace <code>/dev/tty.usbserial-10</code> with the correct port name of the device plugged into your computer via USB.</p> <p>Use <code>demos/build/stm32f103c8/Debug/uart.elf.bin</code> or replace it with any other application to be uploaded.</p> <p>Question</p> <p>Don't know which serial port to use?</p>"},{"location":"getting_started/#on-linux","title":"On Linux","text":"<p>With the device unplugged, run the below command <pre><code>$ ls /dev/ttyUSB*\nls: cannot access '/dev/ttyUSB*': No such file or directory\n</code></pre> Plug the device into the USB port, then rerun the command, the device should appear in the result: <pre><code>$ ls /dev/ttyUSB*\n/dev/ttyUSB0\n</code></pre> The device may also be under the name <code>/dev/ttyACM*</code>, like below <pre><code>$ ls /dev/ttyACM*\n/dev/ttyACM0\n</code></pre> From the above 2 examples for device name, the port name in the <code>stm32loader</code> command would be replaced with <code>/dev/ttyUSB0</code> or <code>/dev/ttyACM0</code> respectively.</p>"},{"location":"getting_started/#on-mac","title":"On Mac","text":"<p>With the device unplugged, run the below command <pre><code>$ ls /dev/tty.usbserial-*\nzsh: no matches found: /dev/tty.usbserial-*\n</code></pre> Plug the device into the USB port, then rerun the command, the device should appear in the result: <pre><code>$ ls /dev/tty.usbserial-*\n/dev/tty.usbserial-14240\n</code></pre></p> <p>From the above example for the device name, the port name in the <code>stm32loader</code> command would be replaced with <code>/dev/tty.usbserial-14240</code>.</p>"},{"location":"getting_started/#on-windows","title":"On Windows","text":"<p>Open Device Manager, by pressing the Windows key and typing \"Device Manager\", then pressing enter.</p> <p>Once the Device Manager window is open, plug the device in to your computer via USB and expand the <code>Ports (COM &amp; LPT)</code> menu. The device should be visible in the list with a COM port like below:</p> <p> From the above screenshot, the port name in the <code>stm32loader</code> command would be replaced with <code>COM3</code>.</p>"},{"location":"getting_started/#changing-built-type","title":"\u26a1\ufe0f Changing Built Type","text":"<p>The build type determines the optimization level of the project. The libhal default for everything is <code>MinSizeRel</code> because code size is one of the most important aspects of the project.</p> <p>You can also change the <code>build_type</code> to following build types:</p> <ul> <li>\ud83e\uddea Debug: Turn on some optimizations to reduce binary size and improve   performance while still maintaining the structure to make debugging easier.   Recommended for testing and prototyping.</li> <li>\u26a1\ufe0f Release: Turn on optimizations and favor higher performance   optimizations over space saving optimizations.</li> <li>\ud83d\udddc\ufe0f MinSizeRel: Turn on optimizations and favor higher space saving   optimizations over higher performance.</li> </ul> <p>To override the default and choose <code>Release</code> mode simply add the following to your conan command: <code>-s build_type=Release</code></p>"},{"location":"getting_started/#creating-a-new-project","title":"\ud83c\udf89 Creating a new Project","text":"<p>Start by cloning <code>libhal-starter</code>:</p> <pre><code>git clone https://github.com/libhal/libhal-starter.git\n</code></pre> <p>Take a look at the <code>README.md</code> of libhal/libhal-starter to get details about how to modify the starter project and make it work for your needs.</p>"},{"location":"summary/","title":"Summary","text":"<ul> <li>\ud83c\udfe1 Home</li> <li>\ud83d\ude80 Getting Started</li> <li>\ud83d\udcd6 User Guide</li> <li>\ud83e\uddf1 Fundamentals of libhal</li> <li>\ud83e\uddd1\ud83c\udfff\u200d\ud83d\udcbb Setting up VSCode</li> <li>\ud83d\udd17 Interfaces in Software Development and libhal</li> <li>\ud83c\udfaf Debugging Code with PyOCD</li> <li>\ud83e\udea4 Error Handling in libhal</li> <li>\u2696\ufe0f Policies &amp; FAQ</li> <li>\ud83c\udfeb Education</li> <li>What are Embedded Systems?</li> <li>Bit Masking</li> <li>Microcontroller Architecture</li> <li>General Purpose I/O</li> <li>DMA</li> <li>Timers &amp; Counters</li> <li>ADC</li> <li>PWM</li> <li>SPI</li> <li>UART</li> <li>I2C</li> <li>DAC</li> <li>CAN BUS</li> <li>Basics of Sensors</li> <li>Basics of Actuators</li> <li>RTOS</li> <li>TBD</li> <li>\ud83d\udcda Contributor Guides</li> <li>\ud83d\udcdc Design Philosophy</li> <li>\ud83d\uddc3\ufe0f Organization</li> <li>\ud83c\udfa8 Style Guide</li> <li>\ud83d\udd17 Interface Design Philosophy</li> <li>\ud83d\udd39 Library Development Guide</li> <li>\ud83e\udde0 ARM Cortex M Bring Up</li> <li>\u23e9 DMA Tutorial</li> <li>\u2b06\ufe0f Upgrade Device Library to 3.x.y</li> <li>\ud83c\udfd7\ufe0f Architectural Design Decisions</li> <li>\ud83d\udcca Project Information</li> <li>\ud83d\udfe2 Library Status \ud83d\udd34</li> <li>About</li> <li>\ud83e\udde9 APIs</li> </ul>"},{"location":"contributor_guide/architecture/","title":"\ud83c\udfd7\ufe0f Architectural Design Decisions","text":""},{"location":"contributor_guide/architecture/#a1-always-use-modern-c","title":"A.1 Always use modern C++","text":"<p>libhal uses the modern C++. Meaning that libhal is will follow the most modern and available compilers available. When a sufficient number of features have become available in both GCC &amp; Clang and are determined to be useful to libhal libhal will increment its major number to indicate that it has upgraded compiler versions.</p> <p>This decision exists to escape the issues of vendor and toolchain lock in thats prevalant in the C++ and embedded industry. With sufficient testing, upgrading compilers shouldn't result in bugs in applications.</p>"},{"location":"contributor_guide/architecture/#a2-interface-design-choices","title":"A.2 Interface Design Choices","text":"<p>Interfaces MUST follow this layout:</p> <ul> <li>Use <code>#pragma once</code> at the start of the file: Simpler than an include guard</li> <li>All <code>virtual</code> functions must be private &amp; each <code>virtual</code> functions is   accompanied by a public API that is used to call the virtual API</li> <li>~~The return type of each API MUST be a <code>result&lt;T&gt;</code> where <code>T</code> is a structure.~~ Amendment 1.0: Return types should never be a structure with the   expectation that it can be grown in the future. This is an ABI break.</li> </ul> <p>Pragma once is needed to ensure files are included once. Its less error prone then hand writing include guards.</p> <p>The reasons for a private virtual with public API can be found in this article (TODO: add link to article).</p> <p>Returning a structure for each API means that, in the future, if the return type needs to be extended, it can be done without breaking down stream libraries. For example:</p> <pre><code>class adc {\n  struct read_t { // V1\n    float percentage;\n  };\n  struct read_t { // V2\n    float percentage;\n    // Optional field that is default initialized to std::nullopt indicating\n    // that it defaults to not exist\n    std::optional&lt;uint8_t&gt; bit_resolution = std::nullopt;\n  };\n};\n</code></pre> <p>Given that the field <code>bit_resolution</code> is an optional, code looking for it can determine if it is available or not, and code that never used it can ignore it.</p>"},{"location":"contributor_guide/architecture/#a21-no-utility-methods-in-interfaces-ufcs","title":"A.2.1 No utility methods in interfaces (UFCS)","text":"<p>Utility functions shall not exist in interface definitions. For example, <code>hal::i2c</code> could have a <code>hal::i2c::write()</code> and <code>hal::i2c::read()</code> function implemented in its interface.</p> <p>This has the effect of reducing the number of headers in the interface files and dependencies. This, in turn, results in an interface that is minimal, clean, and simple.</p> <p>The major purpose of this is to keep compile times down as much possible for each interface. This also ensures that the \"pay-for-what-you-use\" model is followed. No need to pay for a utility you never planned to use.</p> <p>The final reason is in preparation for UFCS (Unified Function Call Syntax). UFCS is a proposal for C++23 and C++26. It did not get into C++23 but is slated for review in 26. For more details see this page What is unified function call syntax anyway?.</p>"},{"location":"contributor_guide/architecture/#a3-using-tweak-files-over-macros","title":"A.3 Using tweak files over macros","text":"<p>Tweak files were used as an alternative to MACROS. MACROs can be quite problematic in many situations and are advised against in the core C++ guidelines. The benefits of tweak files can be found here.</p>"},{"location":"contributor_guide/architecture/#a4-header-only-implementations-see-amendment-a21","title":"A.4 \u274c ~~Header Only Implementations~~ \u27a1\ufe0f (See Amendment A.21)","text":"<p>libhal libraries and drivers are, in general, header-only. libhal uses header only implementations in order to enable the broadest set of package managers, build system and projects to use it.</p> <p>The strongest reason for a header-only approach is due to the fact that libhal libraries never intend to be distributed in prebuilt binaries. Conan is designed to ship with prebuilt binaries or build against the host machine. These settings can be altered, but you still end up with a single global prebuilt binary for a driver does not make sense when that driver could be used in a variety of environments such as the host device for host side tests, a specific target device, and a target device that is in the family of that specific target device.</p> <p>For example, lets consider liblpc40xx. If you are building to target the lpc4078 chip then that prebuilt ought to be built with usage of FPU registers enabled. But if you use that same prebuilt with the lpc4074, you'll find that the program crashes because the 74 variant does not have an FPU. You can attempt make a prebuilt binary for ever possible build variation that an embedded engineer may want, but you'll always come up short. The better approach is to simply build the library each time, thus ensuring that the build flags are considered each time.</p> <p>If compile-times are a concern, there are reasonably easy methods for managing this. See Handling Long Compile Times.</p>"},{"location":"contributor_guide/architecture/#a5-encapsulated-memory-mapped-classes","title":"A.5 Encapsulated Memory Mapped Classes","text":"<p>Target drivers that use Memory-Mapped-IO usually come with a vendor generated header file that describes each peripheral as a structure type, along with bit mask MACROs, and MACROs that result in pointers to each peripheral in memory. The main problem using these headers files causes is naming conflicts. Many of these vendor generated headers work with both C and C++. Meaning that namespaces are not utilized. And many do not expect that they will be used in an environment where another vendor generated header file will exists. So no care is taken to ensure that the names of the types are unique. This WILL cause linker errors as the linker sees both <code>GPIO_TypeDef</code> from an STM library and <code>GPIO_TypeDef</code> from an LPC library that aren't the same.</p> <p>Because of this we have style S.x Encapsulated Memory Mapped classes guideline.</p>"},{"location":"contributor_guide/architecture/#a6-using-halfunction_ref-over-stdfunction","title":"A.6 Using <code>hal::function_ref</code> over <code>std::function&amp;</code>","text":"<p><code>std::function</code> has all of the flexibility and functionality needed, but it has the potential to allocate and requires potentially expensive copy operations when passed by value.</p> <p><code>hal::function_ref</code> is a non-owning version of the <code>std::function</code>, with a size of just two pointers. <code>hal::function_ref</code> fits most use cases in that class functions that take them only need them for the duration of the function and do not need to own them for later.</p> <p>!!! info <code>hal::function_ref</code> is an alias for <code>tl:function_ref</code> which comes from     the project     TartanLlama/function_ref.</p>"},{"location":"contributor_guide/architecture/#a7-using-virtual-runtime-polymorphism","title":"A.7 Using <code>virtual</code> (runtime) polymorphism","text":"<p>Polymorphism is critical for libhal to reach the goals of flexible and easy of use. Static based polymorphism, by its nature, is inflexible at runtime and can be quite complicated to work with.</p> <p>Runtime polymorphism, or the usage of <code>virtual</code> enables a broader scope of flexibility and isolation between drivers and application logic. The only downside to using <code>virtual</code> polymorphism is the cost of a virtual function call. But the actual cost of making a virtual function call is usually tiny in comparison to the work performed in the actual API call. In most cases the call latency and lack of inlining of a virtual call isn't an important factor in most applications.</p> <p>And over all, along with the broad amount of flexibility comes the ease of use. Virtual polymorphism for interfaces is very easy to perform and has a ton of language support.</p>"},{"location":"contributor_guide/architecture/#a8-strongly-leverage-package-managers","title":"A.8 Strongly Leverage Package Managers","text":"<p>Finding and integration libraries into C++ programs is a pain. Doing the same thing for embedded is doubly so, especially if there is vendor IDE lock in. libhal seeks to escape this by using the available package managers and indexes.</p> <p>Libhal was designed around and split up into parts that each come together via these package managers. The purpose of this design is to achieve:</p> <ul> <li>Stable version and release control for each library</li> <li>Can be easily found the indexes</li> <li>Ease of integration</li> </ul>"},{"location":"contributor_guide/architecture/#a9-foundation-interface-stability","title":"A.9 Foundation &amp; Interface Stability","text":"<p><code>libhal-util</code>, <code>libhal-mock</code> and <code>libhal-soft</code> were all apart of <code>libhal</code> originally, but due to the constant changes and API breaks in those categories of code, the version number of <code>libhal</code> would increment constantly, shifting the foundation of the ecosystem. To prevent constant churn and API breaks <code>libhal</code> was split into those 4 libraries.</p> <p>The goal is to keep the version number for <code>libhal</code> constant for long periods of time to prevent breaking down stream libraries, drivers, and applications.</p>"},{"location":"contributor_guide/architecture/#a10-libhal-driver-directory","title":"A.10 libhal driver directory","text":"<p>One of the libhal repos will contain a directory of libhal libraries that extend it along with which interfaces it implements and what type of library it is.</p> <p>Official libhal libraries must go into the directory. Developers outside of the libhal organization can also contribute to and opt into this directory by making a PR to the repo containing the directory.</p> <p>The purpose of this is to make finding and exploring the available set of drivers easier for the end developer by having them all in one place.</p>"},{"location":"contributor_guide/architecture/#a11-github-actions-remote-workflows","title":"A.11 Github Actions &amp; Remote Workflows","text":"<p>libhal uses github and github action \"workflow_dispatch\" to allow other repos to reuse libhal's continuous integration steps. The actions are configurable via input parameters to allow libraries to customize and control how the CI works.</p> <p>libhal's CI attempts to use as many tools as reasonable to make sure that the C++ source code follows the style guide, C++ core guidelines and retains a certain level of quality. All offical libhal libaries must opt in to the common libhal/libhal workflow.</p> <p>This helps to ensure that all projects are held to the same standard and quality. The workflow files can be found in <code>libhal/libhal/.github/workflows</code>.</p>"},{"location":"contributor_guide/architecture/#a12-boostut-as-our-unit-testing-framework","title":"A.12 Boost.UT as our unit testing framework","text":"<p>Boost.UT was chosen for its lack of macros, stunning compile time performance, and its ease of use.</p>"},{"location":"contributor_guide/architecture/#a13-boostleaf-for-error-handling-see-amendment-a22","title":"A.13 \u274c ~~Boost.LEAF for error handling~~ \u27a1\ufe0f (See Amendment A.22)","text":"<p>One major issue with any project is handling errors. Because the <code>libhal</code> interfaces can be used in such broad environments, it is hard to determine what the BEST error type in advance could work for all users. Some use error codes, some use <code>std::expected&lt;T, E&gt;</code>, and some use exceptions.</p> <p>Error codes are problematic as they tend to lack details and context around an error. Sometimes the documentation along with the error code provides all of the necessary context, but many times more context is needed.</p> <p><code>std::expected&lt;T, E&gt;</code> seems like a better alternative to error codes, but... is it really? What should <code>E</code> be? An error code? What if we have it be an error code and a const string. What if we want a file name and function name? What about a line number? What about 16 bytes for holding context information about the error? That should be enough, right? What about- what about- what about? ... wait, how big is this error type? 32 bytes? Wasn't this supposed to be light weight? Unfortunately, <code>std::expected</code> is not a good choice for interfaces with extremely broad and unknowable of error states. This forces the error type to be massive to accommodate everything and everyone.</p> <p>Exceptions somewhat fix this issue but are still lacking. The benefit of exceptions is that you can throw just about anything, meaning the developer can provide loads of information in the thrown object. But exceptions fail on 4 counts:</p> <ul> <li>Exceptions tend to not be available for embedded systems, either due to a     toolchain not compiling with them enabled or because a project has strict     requirements that forbid exceptions.</li> <li>When exceptions do occur, the amount of time it takes to reach its catch can     take a long time, longer than what real time applications can handle.</li> <li>Normally requires heap allocation</li> <li>Exceptions can only throw one type and the cost of those thrown exceptions     are always paid for.</li> </ul> <p>Boost.LEAF has the following properties:</p> <ul> <li>Portable single-header format, no dependencies.</li> <li>Tiny code size when configured for embedded development.</li> <li>No dynamic memory allocations, even with very large payloads.</li> <li>Deterministic unbiased efficiency on the \"happy\" path and the \"sad\" path.</li> <li>Error objects are handled in constant time, independent of call stack depth.</li> <li>Can be used with or without exception handling.</li> <li>Can throw more than 1 error at a time</li> </ul> <p>All of these features are critical for libhal to have the performance for real time applications.</p> <p>The last feature is important for debugging, bug reports, and context specific error handling. Boost.LEAF gives the driver the choice to emit several error types and allows the user to pick out which one they would like to opt to catch if any of them. This can be used to capture an error code as well as s snapshot of the register map of a peripheral, the object's current state or even a debug message.</p>"},{"location":"contributor_guide/architecture/#a14-using-statement-expressions-with-hal_check-see-amendment-a22","title":"A.14 ~~Using Statement Expressions with <code>HAL_CHECK()</code>~~ \u27a1\ufe0f (See Amendment A.22)","text":"<p><code>HAL_CHECK()</code> is the only MACRO in <code>libhal</code>. It exists because there is nothing like Rust's <code>?</code> operator which either unwraps a value or returns an error from the current function. The \"Statement Expression\" only works with GCC &amp; Clang which is one of the reasons why <code>libhal</code> only supports those compilers. Compare the following two expressions:</p> <pre><code>// 1. Using statement expressions\nauto percentage = HAL_CHECK(adc.read()).percentage;\n\n// 2. Without using statement expressions\nHAL_CHECK(adc_read_temporary, adc.read());\nauto percentage = adc_read_temporary.percentage;\n</code></pre> <p>The second option looks very unnatural and require explanation. On the other hand users who have never seen <code>HAL_CHECK()</code> in action have an immediate idea of how it works in the first section of the code. Portability to other compilers was sacrificed in order to make the code easier to read, understand, and write.</p>"},{"location":"contributor_guide/architecture/#a15-libhal-will-not-use-fixed-point","title":"A.15 <code>libhal</code> WILL NOT use fixed point","text":"<p>Because fixed point will NOT result in better performance or space savings compared to SOFTWARE floating point. Team did venture to use fixed point throughout the entire code base and when we felt that the fixed point code reached a point where it was usable everywhere, we benchmarked it and got these:</p> <pre><code>double_time            = 8921794\n[i64 +Round]fixed_time = 4558238 (best fixed point option)\n[soft]float_time       = 1424913\n[i64 -Round]fixed_time = 1410720 (precision issues)\n[i32 +Round]fixed_time = 815107  (will easily overflow)\n[hard]float_time       = 110089  (not always available)\n[i32 -Round]fixed_time = 95085   (will not actually work)\n</code></pre> <p>Here is an old gist of the example: kammce/fixed_v_float.cpp</p> <p>The above metrics were for a program that run a map function to map an input number from one range to another range. The numbers on the right hand side are the number of cycles of a Arm Cortex M4F DWT counter. Fixed point 32-bit integers is enough for a representation but to handle arithmetic like multiplication, 64-bit integers were needed. Those 64-bit operations resulted in computation time approaching double floating point. If a system used 32-bit floats, the 32-bit fixed point would be ~4x slower. If a system used double floating point in software mode, it will only be ~2x slower than 32-bit fixed point. Fixed point, over all, is more expensive in terms of space and time.</p> <p>If you don't believe the metrics measured here, you can also check fpm performance metrics. Notice how fpm fairs far worse for anything that isn't addition/subtraction.</p> <p>See these articles for more details:</p> <ul> <li>You're Going To Have To   Think!</li> <li>WHY FIXED POINT WON'T CURE YOUR FLOATING POINT   BLUES</li> <li>WHY RATIONALS WON\u2019T CURE YOUR FLOATING POINT   BLUES</li> <li>Why Computer Algebra Won\u2019t Cure Your Floating Point   Blues</li> <li>Why Interval Arithmetic Won\u2019t Cure Your Floating Point   Blues</li> </ul>"},{"location":"contributor_guide/architecture/#a16-libhal-does-not-use-a-units-library","title":"A.16 <code>libhal</code> does NOT use a units library","text":"<p>Unit libraries have the potential to really help prevent an entire category of unit based errors, it is also extremely difficult and annoying to use.</p> <p>Th article Unit of measurement libraries, their popularity and suitability goes into detail about the usability issues faced by unit libraries. Because, at the time of writing <code>libhal</code> there is not a unit library that is easy to use and concise, <code>libhal</code> decided to simply stick with 32-bit floats and helper UDLs.</p>"},{"location":"contributor_guide/architecture/#a17-always-return-halresultt-from-every-api-see-amendment-a22","title":"A.17 ~~Always return <code>hal::result&lt;T&gt;</code> from every API~~ \u27a1\ufe0f (See Amendment A.22)","text":"<p>Every interface in libhal returns a <code>hal::result&lt;T&gt;</code> type.</p> <p>The return types should be a <code>result&lt;T&gt;</code> because the implementation could be an abstraction for anything. As an example, it could come from an I2C to PWM generator and if something goes wrong with the i2c communication, the information must be emitted from the function.</p>"},{"location":"contributor_guide/architecture/#a18-using-inplace_functionhalcallback-for-interrupt-callbacks","title":"A.18 Using <code>inplace_function</code>/<code>hal::callback</code> for interrupt callbacks","text":"<p>There are interfaces such as <code>hal::can</code>, <code>hal::interrupt_pin</code>, and <code>hal::timer</code> that all have APIs for setting a callback.</p> <p>Because those callbacks could be lambdas, function objects, pure functions, or other callable types, we need a polymorphic type erased function type that can take any callable type as input and call it when its <code>operator()</code> is called.</p> <p>The options for these callbacks are:</p> <ul> <li><code>std::function</code><ul> <li>PROS<ul> <li>Part of the standard library</li> <li>Can take any callable type without restrictions</li> </ul> </li> <li>CONS<ul> <li>Allocating (compiler implementations will use SBO but the size of   those buffers are not specified in the standard and should not be   relied upon)</li> <li>Can be quite large in size (40 bytes on 32-bit arm)</li> </ul> </li> </ul> </li> <li><code>function_ref</code><ul> <li>PROS<ul> <li>Very lightweight (very fast construction)</li> <li>Very small size (2 pointers in size)</li> </ul> </li> <li>CONS<ul> <li>For this to work as a callback, the callable passed to the   <code>function_ref</code> must have a lifetime that is greater than the object   implementing the interface.</li> </ul> </li> </ul> </li> <li><code>inplace_function</code><ul> <li>PROS<ul> <li>Works and behaves just like <code>std::function</code></li> </ul> </li> <li>CONS<ul> <li>Fixed callable size limit</li> </ul> </li> </ul> </li> </ul> <p><code>std::function</code> is automatically out because it is allocating. Using <code>std::function</code> for any interface API would ensure that applications that disallow dynamic allocations after boot or in general could never use them.</p> <p><code>function_ref</code> has two great PROS but the largets CON is lifetime issues that are really easy to fall into. Specifically something like this:</p> <pre><code>obj.on_event([&amp;single_capture]() {\n  // does a thing  ...\n});\n</code></pre> <p>The lambda is actually a temporary! So after this call it is out of scope and no longer exists. If the reference to temporary is stored and called later, the code WILL suffer from a \"stack use after scope\" violation which is undefined behavior.</p> <p><code>inplace_function</code> has all of the features of <code>std::function</code> but with limited size. Due to this, constructing an <code>inplace_function</code> is deterministic and relatively light weight.</p>"},{"location":"contributor_guide/architecture/#a19-halcallback-sizing","title":"A.19 <code>hal::callback</code> sizing","text":"<p><code>hal::callback</code> is an alias to <code>inplace_function</code> with a buffer size of 2 pointers (<code>sizeof(std::intptr_t) * 2</code>). This size was chosen in order to be small and easily storable. Two pointers worth of size should be enough to hold a pointer to <code>this</code> in classes as well a pointer to some sort of state object.</p> <p>The size of the callback object was not choosen in order to improve the performance of calling callback setting class functions. Even with the small size of <code>hal::callback</code>, its too large to take advantage of register based parameter passing. Thus the size of 2 pointers was mostly to help in keeping the memory footprint of the <code>callback</code> small. In most cases, setting an callback is something that is either done once or done very infrequently, and thus does not get much of a benefit from higher performance function calls.</p>"},{"location":"contributor_guide/architecture/#a20-why-functions-that-setup-events-do-not-return-halstatus-see-amendment-a22","title":"A.20 ~~Why functions that setup events do not return <code>hal::status</code>~~  \u27a1\ufe0f (See Amendment A.22)","text":"<p>Functions like <code>hal::can::on_receive()</code> and <code>hal::interrupt_pin::on_trigger()</code> return void and not <code>hal::status</code> like other APIs. Thus these functions cannot return an error and are considered \"infallible\". There infallibility guarantee makes constructing drivers using these interfaces easier. It also eliminates the need for drivers to concern themselves with handling errors from these APIs.</p> <p>This guarantee is easily made, because having any one of these APIs fail IS A bug and not something that a developer should or could be responsible with handling. These APIs MUST be implemented as target library peripheral drivers because setting interrupts is something that only target and processor libraries can do. Setting up and configuring interrupts is only possible if the processor supports it. Being apart of a target library means that they know exactly the set of possible configurations that are allowed. This also means that constructing a target peripheral with interrupt customization can be include compile time checks as well.</p>"},{"location":"contributor_guide/architecture/#a21-critical-importance-of-providing-prebuilt-binaries","title":"A.21 Critical importance of providing prebuilt binaries","text":"<p>This amends architectural component A.4 and pivots away from header only libraries over to prebuilt binaries.</p> <p>The following are the reasons why supporting, producing and distibuting prebuilt binaries is critical to libhal.</p> <ul> <li>\u23f1\ufe0f Faster compilation times: When a project grows in size, compiling   a C++ codebase can become time-consuming. By using precompiled binaries,   the compiler has less work to do because portions of the code have already   been compiled. It doesn't need to parse and compile the same headers over and   over again. Developers will refuse to use libhal if it results in extremely   long compilation times. They will tire of the project and seek faster to   compile alternatives.</li> <li>\u2705 Consistency: With precompiled binaries, you can be sure that the same   code will be compiled in the same way, which can reduce inconsistencies   between different environments or build configurations. libhal will not be   taken seriously if libhal didn't use prebuilt binaries and also support   producing them. Distributing consistent code in a consistent form will be a   requirement for many organizations seeking to use libhal.</li> <li>\ud83d\udce6 Code distribution and updates: When distributing C++ code, rather than   give out the full source code or require users to compile it themselves,   providing a precompiled binary is more user-friendly. Updates to the program   can also be handled by replacing the old binaries with the new ones, without   requiring the end-user to handle the compilation process. The philosophy of   conan regarding library packages is that, at their core, C++ libraries are   header files and prebuilt binaries.</li> <li>\ud83d\udd12 Protection of Intellectual Property: Precompiled binaries are much   harder to reverse-engineer than raw source code. If a developer wants to   write an application and distribute the binary, but the C++ code contains   proprietary algorithms or trade secrets that you don't want to expose to the   public, distributing it as a precompiled binary can provide an additional   layer of protection.</li> </ul> <p>In order to provide the best experience for our developers as well as necessary features of the platform, libhal emphasizes prebuilt libraries over header only.</p> <p>Note</p> <p>Why the sudden change from A.4 to this? Supporting header-only made bringing up libhal much easier. The process of implementing prebuilt binaries required adding additional architecture settings, required the use of conan profiles to make the arm-gnu-toolchain available globally for all packages, figuring out how to insert architectural compiler flags and ensure they propogate to all packages took time and was a complex process. And header-only libraries allowed the initial version of libhal to bypass all of this.</p>"},{"location":"contributor_guide/architecture/#a22-use-c-exception-for-error-handling","title":"A.22 Use C++ Exception for Error handling","text":"<p>libhal uses C++ exceptions for these reasons:</p> <ol> <li>Removes runtime cost of calling functions that error codes, result types,    and sentinel variables.</li> <li>Reduces code size greatly by:</li> <li>Amortizing the error handling mechanism to a single set of functions       rather than distributing the workload across all functions that can error.</li> <li>Unwind information is a compressed ISA that only needs 8 bits per       instruction in ARM (32 and 64), where as normal ARM or Thumb-2 which require 16 to 32 bits of information, resulting in code bloat.</li> <li>GCC's Language Specific Data Area (LSDA) is a further compressed data       structure for determining if a frame contains a suitable catch block or cleanup routine.</li> </ol> <p>Issues regarding memory allocations can be overcome by simply overriding/ wrapping <code>__cxa_allocate_exception</code> and using a statically allocated buffer.In the case of multiple threads, each thread can be given its own memory buffer through TLS or a circular pool of blocks with an <code>std::atomic&lt;int&gt;</code> for every thread to use.</p> <p>Exception throw runtime can be reduced by optimizing <code>__cxa_throw</code>'s implementation.</p> <p>The runtime is determinist because the grand majority of our code is statically linked. This means our code is not concerned with shared library locking the exception table down with a mutex to update it. This mutex lock will blocking threads from continuing to unwind, making the time non-determinist. Once you remove that, your unwind time is deterministic.</p> <p>The issue with massive code bloat when you enable <code>-fexceptions</code> only comes from the linux version of <code>std::terminate</code> which uses <code>&lt;iostream&gt;</code> and some other locale related stuff. Simply overriding this with your own implmentation fixes this issue and reduces code size by ~100kB.</p> <p>A link to a paper written by Khalil Estell will be linked here to describe in detail why C++ exception handling is the superior error handling mechanism for embedded systems and software in general when performance and code size are critical concerns.</p>"},{"location":"contributor_guide/arm_cortex_m_bringup/","title":"\ud83e\udde0 ARM Cortex-M Series Platform Bringup","text":"<p>To fully bring up an ARM Cortex-M series microcontroller for libhal, several critical elements need to be implemented:</p> <ol> <li>Conan profiles</li> <li>Linker scripts</li> <li>Continuous Integration &amp; Deployment</li> <li>Platform Constants</li> <li>Core APIs</li> </ol> <p>To ensure peripheral drivers operate without conflicts, such as clashing power control implementations, the following APIs must be implemented:</p> <ol> <li>Power control</li> <li>Pin Multiplexing</li> <li>Clock tree</li> <li>Direct Memory Access (DMA)</li> </ol> <p>While not all devices support these features, and many drivers can function without them, implementing them ensures comprehensive peripheral support. For instance, on the LPC40xx series, GPIOs are enabled by default, and simple tasks like blinking an LED don't require knowledge of the system's clock speed or DMA.</p> <p>However, accommodating all features enables support for all potential peripheral drivers.</p> <p>Keep in mind that, as with all libhal tutorials, adaptability is key. Some chips may deviate from standard architectures; in such cases, a fundamental understanding and sound judgment are essential to ensure your system functions effectively.</p>"},{"location":"contributor_guide/arm_cortex_m_bringup/#getting-started","title":"\ud83d\ude80 Getting Started","text":"<p>libhal provides a template repository for ARM Cortex-M series platforms. Begin by visiting <code>libhal-__platform__</code>, clicking \"Use this template,\" and then \"Create new repository.\"</p> <p>Your project should be named <code>libhal-&lt;insert platform name&gt;</code>. This standard naming triggers the GitHub action update_name.yml to create a pull request that updates names and files within the repo from <code>__platform__</code> to your chosen name. Merge this pull request to proceed to the next phase.</p> <p>Note</p> <p>If there is demand for platform names without the <code>libhal-</code> prefix, we can modify <code>update_name.yml</code> to accommodate this. Currently, we support only prefixed package names.</p>"},{"location":"contributor_guide/arm_cortex_m_bringup/#conan-profiles","title":"\ud83c\udf10 Conan Profiles","text":"<p>Libhal leverages Conan's robust profile system to specify the architecture and operating system for which an application is built. If you are new to libhal, refer to the \"Getting Started\" guide for details on building applications using compiler and platform profiles.</p> <p>A microcontroller family consists of microcontrollers with nearly identical designs but variations in memory, storage, and peripherals. Since these variations share a common architecture, drivers can typically operate across the family.</p> <p>Creating a Conan profile begins with understanding the device family. This determines the number of profiles needed. For example, the RP2040, which is a single-device family, would have one profile simply named <code>rp2040</code>. However, a chip family with 15 variations would require a distinct profile for each variant.</p>"},{"location":"contributor_guide/arm_cortex_m_bringup/#components-of-a-typical-profile","title":"Components of a Typical Profile","text":"<p>Below is an example of a Conan profile for the <code>rp2040</code> microcontroller:</p> <pre><code>[settings]\nbuild_type=MinSizeRel\nos=baremetal\narch=cortex-m0plus\nlibc=custom\n\n[options]\n*:platform=rp2040\n</code></pre>"},{"location":"contributor_guide/arm_cortex_m_bringup/#explanation-of-settings","title":"Explanation of Settings","text":"<ul> <li><code>[settings]</code>: This section configures the build environment for your code.</li> <li><code>build_type</code>: Defaults to <code>MinSizeRel</code>, optimizing for the smallest   binary size, which is crucial for embedded applications.</li> <li><code>os</code>: Always set to <code>baremetal</code> for ARM Cortex-M processors, indicating a   direct hardware operation without a traditional operating system.</li> <li><code>arch</code>: Specifies the processor architecture. It is essential to consult   the user manual to identify the correct architecture as variations within the   same family may exist. For instance, the LPC4078 uses a Cortex-M4F (with   floating point unit), unlike the LPC4072, which uses a Cortex-M4 (without   floating point unit). Supported architectures include <code>cortex-m0</code>,   <code>cortex-m0plus</code>, <code>cortex-m1</code>, <code>cortex-m3</code>, <code>cortex-m4</code>, <code>cortex-m4f</code>,   <code>cortex-m7</code>, <code>cortex-m7f</code>, <code>cortex-m7d</code>, <code>cortex-m23</code>, <code>cortex-m33</code>,   <code>cortex-m33f</code>, <code>cortex-m33p</code>, <code>cortex-m35p</code>, <code>cortex-m55</code>, and <code>cortex-m85</code>.</li> <li><code>libc</code>: Should be set to <code>custom</code> to accommodate picolibc, which is   preferable over the default newlib-nano used by the GNU ARM toolchain.</li> </ul>"},{"location":"contributor_guide/arm_cortex_m_bringup/#options-section","title":"Options Section","text":"<ul> <li><code>[options]</code>: This section defines library options for the build process.   It facilitates the selection of specific package options within   <code>conanfile.py</code>.</li> <li><code>*:platform=rp2040</code>: This setting universally applies the <code>rp2040</code>   platform option across all packages, using <code>*</code> as a wildcard to ensure it   affects all compiled packages.</li> </ul>"},{"location":"contributor_guide/arm_cortex_m_bringup/#customizing-your-profile","title":"Customizing Your Profile","text":"<p>To tailor this profile for different platforms, replace <code>rp2040</code> with the relevant platform name and adjust <code>arch</code> to match the specific CPU architecture of your device. This customized approach ensures that the build settings are perfectly aligned with the hardware specifications of the microcontroller you are working with.</p>"},{"location":"contributor_guide/arm_cortex_m_bringup/#using-profile-templates","title":"Using Profile Templates","text":"<p>Conan has the ability to use Jinja templates in its profiles allowing for the composition and expansion of profiles. So if you have a ton of devices in the same family with nearly identical bits of information, you can make a template for them. Check out the following examples:</p> libhal-lpc40libhal-stm32f1 <p>Notice how the only thing that changes between these are the architecture and the platform.</p> <p><code>libhal-lpc40/conan/v2/lpc40</code>:</p> <pre><code>[settings]\nbuild_type=MinSizeRel\nos=baremetal\narch={{ arch }}\nlibc=custom\n\n[options]\n*:platform={{ platform }}\n</code></pre> <p><code>libhal-lpc40/conan/v2/lpc4078</code>:</p> <pre><code>{% set platform = \"lpc4078\" %}\n{% set arch = \"cortex-m4f\" %}\n{% include \"lpc40\" %}\n</code></pre> <p><code>libhal-lpc40/conan/v2/lpc4072</code>:</p> <pre><code>{% set platform = \"lpc4072\" %}\n{% set arch = \"cortex-m4\" %}\n{% include \"lpc40\" %}\n</code></pre> <p>The only difference between the chips with respect to the settings and options is just the platform name so the template only needs to be used for the platform variable.</p> <p><code>libhal-stm32f1/conan/v2/stm32f103</code>: <pre><code>[settings]\nbuild_type=MinSizeRel\nos=baremetal\narch=cortex-m3\nlibc=custom\n\n[options]\n*:platform={{ platform }}\n</code></pre></p> <p><code>libhal-stm32f1/conan/v2/stm32f103c8</code>: <pre><code>{% set platform = \"stm32f103c8\" %}\n{% include \"stm32f1\" %}\n</code></pre></p> <p><code>libhal-stm32f1/conan/v2/stm32f103vc</code>: <pre><code>{% set platform = \"stm32f103vc\" %}\n{% include \"stm32f1\" %}\n</code></pre></p>"},{"location":"contributor_guide/arm_cortex_m_bringup/#directory-structure","title":"Directory structure","text":"<p>In order to allow changes into the future, it is advised to put your profiles in a <code>v1</code> or <code>vN</code> directory. This way, if there is a significant change between the profiles into the future, code can still use the original profiles they used before.</p>"},{"location":"contributor_guide/arm_cortex_m_bringup/#linker-scripts","title":"\ud83d\udd17 Linker Scripts","text":"<p>Linker scripts play a crucial role in defining the memory layout of embedded systems. They are used to organize different types of data within the binary, such as code, initialized data, uninitialized data, read-only data, and thread local storage. These scripts also outline the memory regions available for the application.</p> <p>The finer details about linker scripts and how they work can be found in the resources below:</p> <ul> <li>Mastering the GNU linker script by AllThingsEmbeddd: Easy to learn 13 min read</li> <li>\"The most thoroughly commented linker script (probably)\" by Thea \"Stargirl\" Flowers:   A very thoroughly documented and easy read on linker scripts</li> <li>GNU Linker Scripts: Full user specification, if you need or want those details</li> </ul> <p>This section will not go into detail about linker scripts but will provide you all of the steps to port your device to libhal platform library.</p>"},{"location":"contributor_guide/arm_cortex_m_bringup/#standard-linker-script-template","title":"Standard Linker Script Template","text":"<p>The <code>libhal-armcortex</code> library provides standardized linker script templates, which can be easily adapted for specific platforms. An example template is available at: <code>libhal-armcortex/linker_scripts/libhal-armcortex/standard.ld</code>.</p> <p>To utilize these templates, include the following definitions in your linker scripts directory:</p> <pre><code>__flash = 0x00000000;\n__flash_size = 64K;\n__ram = 0x10000000;\n__ram_size = 16K;\n__stack_size = 1K;\n\nINCLUDE \"libhal-armcortex/standard.ld\"\n</code></pre> <p>The above configuration is an example from the <code>lpc4072</code> script.</p>"},{"location":"contributor_guide/arm_cortex_m_bringup/#customizing-linker-scripts","title":"Customizing Linker Scripts","text":"<p>You need to specify:</p> <ul> <li>The location and size of the flash memory within the device's address space.</li> <li>The location and size of the main RAM.</li> <li>The minimum stack size before the build should fail, typically set to <code>1K</code>   for libhal. Adjust this based on available RAM.</li> </ul> <p>Each variation within a chip family, such as those in the LPC40xx series, requires its own linker script due to differences in flash and RAM sizes:</p> <p>For example the chips in the LPC40xx series are:</p> <ul> <li>lpc4072</li> <li>lpc4074</li> <li>lpc4076</li> <li>lpc4078</li> <li>lpc4088</li> </ul> <p>Each has their own unique ram and flash amounts.</p> <p>Similarly, the STM32F10x series has distinct linker scripts for each variant based on flash and RAM requirements, such as:</p> <ul> <li>stm32f10xx4.ld</li> <li>stm32f10xx6.ld</li> <li>stm32f10xx8.ld</li> <li>stm32f10xxb.ld</li> <li>stm32f10xxc.ld</li> <li>stm32f10xxd.ld</li> <li>stm32f10xxe.ld</li> <li>stm32f10xxf.ld</li> <li>stm32f10xxg.ld</li> </ul> <p>The STM32F103C8 belongs to the STM32F1 series of microcontrollers, which are part of the STM32 family of devices from STMicroelectronics. The naming scheme for this series can be broken down as follows:</p> <ul> <li>STM32: Indicates the family of ARM Cortex-M microcontrollers.</li> <li>F1: Indicates the series within the STM32 family, specifically the   STM32F1 series.</li> <li>03: Indicates the sub-family, which in this case is the STM32F103   sub-family. The '1' before '03' generally represents the sub-category within   the series.</li> <li>C: Indicates the package type and number of pins (e.g., 'C' typically   indicates an LQFP48 package with 48 pins).</li> <li>8: Indicates the memory size, specifically the Flash memory size, in this   case, 64 KB of Flash memory.</li> </ul> <p>All devices in this family have just 20kB of RAM. Thus the only part of the profile name that matters in terms of determining the appropriate flash size is the last digit. That digits can be <code>4</code>, <code>6</code>, <code>8</code>, <code>b</code>, <code>c</code>, <code>d</code>, <code>e</code>, <code>f</code>, <code>g</code>, which is why we have that many linker scripts above. The exact reason why each number and letter is used is not known to the writer, but is also not important. All that we need to do is map those profile names to the correct <code>.ld</code> file.</p>"},{"location":"contributor_guide/arm_cortex_m_bringup/#handling-multiple-flash-and-ram-configurations","title":"Handling Multiple Flash and RAM Configurations","text":"<p>Currently, <code>libhal-armcortex</code> supports MCUs with single flash and RAM configurations. For support for multi-flash and multi-RAM devices, consider contributing or following the development on this GitHub issue: Add multi flash &amp; multi ram linker scripts. In order to communicate to the build system what your linker scripts are and where to find them, we must add to the conan package's <code>cpp_info.exelinkflags</code> array. This property describes to conan what link flags should be added if a package depends on this package. See the code below.</p>"},{"location":"contributor_guide/arm_cortex_m_bringup/#integrating-linker-scripts-into-build-systems","title":"Integrating Linker Scripts into Build Systems","text":"<p>To properly integrate your linker scripts with the Conan build system, add the appropriate link flags to the <code>cpp_info.exelinkflags</code> array in your package. This setup ensures that the linker scripts are correctly recognized and used during the build process.</p> <pre><code>def package_info(self):\n    self.cpp_info.set_property(\"cmake_target_name\", \"libhal::__platform__\")\n    self.cpp_info.libs = [\"libhal-__platform__\"]\n\n    if self.settings.os == \"baremetal\" and self._use_linker_script:\n        self.add_linker_scripts_to_link_flags()\n\ndef add_linker_scripts_to_link_flags(self):\n    platform = str(self.options.platform)\n    self.cpp_info.exelinkflags = [\n        \"-L\" + os.path.join(self.package_folder, \"linker_scripts\"),\n        \"-T\" + os.path.join(\"libhal-__platform__\", platform + \".ld\"),\n    ]\n</code></pre>"},{"location":"contributor_guide/arm_cortex_m_bringup/#implementing-linker-scripts-for-your-platform","title":"Implementing Linker Scripts for Your Platform","text":""},{"location":"contributor_guide/arm_cortex_m_bringup/#1-download-and-review-the-user-manual","title":"1. Download and Review the User Manual","text":"<p>Begin by downloading and reviewing the user manual for your microcontroller. The datasheet may provide some information, but the user manual will typically contain a comprehensive memory map. Search for the section labeled \"memory map\" to find detailed information about the sizes of the device's flash and RAM.</p>"},{"location":"contributor_guide/arm_cortex_m_bringup/#2-determine-the-naming-scheme","title":"2. Determine the Naming Scheme","text":"<p>Device naming schemes vary. Some, like the <code>lpc4078</code>, have straightforward names, while others, like the <code>stm32f10x</code>, incorporate coded symbols. Establish a clear naming strategy for your linker scripts. Each profile should correspond to exactly one linker script, although a single linker script can apply to multiple profiles if the hardware characteristics are identical.</p>"},{"location":"contributor_guide/arm_cortex_m_bringup/#3-populate-the-linker-script","title":"3. Populate the Linker Script","text":"<p>Fill out the linker script with the specific memory addresses and sizes for your device:</p> <pre><code>__flash = ???;\n__flash_size = ???;\n__ram = ???;\n__ram_size = ???;\n__stack_size = 1K;\n\nINCLUDE \"libhal-armcortex/standard.ld\"\n</code></pre>"},{"location":"contributor_guide/arm_cortex_m_bringup/#4-repeat-for-all-variants","title":"4. Repeat for All Variants","text":"<p>Continue this process for each device variant within the chip family, ensuring that all have appropriate linker scripts reflecting their specific memory configurations.</p>"},{"location":"contributor_guide/arm_cortex_m_bringup/#5-update-add_linker_scripts_to_link_flags-in-conanfilepy","title":"5. Update <code>add_linker_scripts_to_link_flags()</code> in <code>conanfile.py</code>","text":"<p>Modify the <code>add_linker_scripts_to_link_flags()</code> function in your <code>conanfile.py</code> to correctly link the appropriate scripts based on the platform:</p> <p>For devices like the STM32 family, where multiple variants exist, implement a dynamic approach to link the correct script:</p> <pre><code>def add_linker_scripts_to_link_flags(self):\n    linker_script_name = list(str(self.options.platform))\n    # Replace unneeded characters with 'x' to denote a generic script\n    linker_script_name[8] = 'x'\n    linker_script_name[9] = 'x'\n    linker_script_name = \"\".join(linker_script_name)\n\n    self.cpp_info.exelinkflags = [\n        \"-L\" + os.path.join(self.package_folder, \"linker_scripts\"),\n        \"-T\" + os.path.join(\"libhal-stm32f1\", linker_script_name + \".ld\"),\n    ]\n</code></pre> <p>This adjustment allows you to use a single script for similar variants by replacing specific parts of the chip identifier with a 'don't care' symbol ('x'). Think of it like bit masking but for letters.</p> <p>For some devices with XIP (eXecute In Place) external flash memory interfaces packages can opt to conan's package \"option\" feature, allowing the user to specify the size in the command line, their own profile, or set the option directly in the final application <code>conanfile.py</code>.</p>"},{"location":"contributor_guide/arm_cortex_m_bringup/#6-testing","title":"6. Testing","text":"<p>Once all scripts are in place, it's time to test:</p> <p>To build the package, run: <pre><code>conan create . -pr YOUR_PROFILE -pr arm-gcc-12.3 --version=latest\n</code></pre></p> <p>To build your demos, use: <pre><code>VERBOSE=1 conan build demos -pr YOUR_PROFILE -pr arm-gcc-12.3\n</code></pre></p> <p>On Windows: <pre><code>$env:VERBOSE=1 conan build demos -pr YOUR_PROFILE -pr arm-gcc-12.3\n</code></pre></p> <p>Ensure verbose output is enabled to check the <code>-Tyour_linker_script.ld</code> command argument during the build process. Verify the binary fits the addresses specified in the linker script with:</p> <pre><code>arm-none-eabi-readelf -S demos/build/YOUR_PROFILE/MinSizeRel/blinker.elf\n</code></pre> <p>Confirm the <code>.init</code> section aligns with the flash address and <code>.data</code> with the RAM address. If these match, your implementation is successful.</p> <p>Troubleshooting</p> <p>If commands do not execute as expected, particularly on Linux or macOS, source your environment variables with:</p> <pre><code>source demos/build/YOUR_PROFILE/MinSizeRel/generators/conanbuild.sh\n</code></pre>"},{"location":"contributor_guide/arm_cortex_m_bringup/#continuous-integration-deployment","title":"\ud83d\udd04 Continuous Integration &amp; Deployment","text":"<p>Continuous Integration (CI) ensures that code in the main branch of any libhal library\u2014or code intended for the main branch\u2014builds successfully and passes all tests. This process is crucial for maintaining code quality and functionality over time.</p> <p>Warning</p> <p>The CI system is currently optimized for use within the libhal organization. Efforts are underway to enhance its usability for other organizations without requiring a fork or clone of the <code>libhal/ci</code> repository.</p>"},{"location":"contributor_guide/arm_cortex_m_bringup/#branch-pull-request-checks","title":"Branch &amp; Pull Request Checks","text":"<p>The <code>libhal-__platform__</code> includes a pre-configured <code>ci.yml</code> GitHub Action script, which provides an overview of our automated testing approach:</p> <pre><code>on:\n  workflow_dispatch:\n  pull_request:\n  push:\n    branches:\n      - main\n  schedule:\n    - cron: \"0 12 * * 0\"\n</code></pre> <p>Key Features:</p> <ul> <li>Scheduled Tests: The CI system automatically tests the main branch daily   to ensure ongoing compatibility and to detect any issues caused by changes in   other packages or the infrastructure.</li> <li>Pull Request Tests: All pull requests undergo CI tests to ensure that new   contributions do not introduce bugs or compatibility issues.</li> <li>Manual Trigger: The <code>workflow_dispatch</code> event allows for manual CI runs   without needing to push updates or create pull requests.</li> </ul> <pre><code>jobs:\n  library_checks:\n    uses: libhal/ci/.github/workflows/library_check.yml@5.x.y\n    secrets: inherit\n\n  deploy_cortex-m4f_check:\n    uses: libhal/ci/.github/workflows/deploy.yml@5.x.y\n    with:\n      arch: cortex-m4f\n      os: baremetal\n      compiler: gcc\n      compiler_version: 12.3\n      compiler_package: arm-gnu-toolchain\n    secrets: inherit\n\n  deploy_cortex-m4_check:\n    uses: libhal/ci/.github/workflows/deploy.yml@5.x.y\n    with:\n      arch: cortex-m4\n      os: baremetal\n      compiler: gcc\n      compiler_version: 12.3\n      compiler_package: arm-gnu-toolchain\n    secrets: inherit\n\n  demo_check_profile1:\n    uses: libhal/ci/.github/workflows/demo_builder.yml@5.x.y\n    with:\n      compiler_profile_url: https://github.com/libhal/arm-gnu-toolchain.git\n      compiler_profile: v1/arm-gcc-12.3\n      platform_profile_url: https://github.com/libhal/libhal-__platform__.git\n      platform_profile: v1/profile1\n    secrets: inherit\n\n  demo_check_profile2:\n    uses: libhal/ci/.github/workflows/demo_builder.yml@5.x.y\n    with:\n      compiler_profile_url: https://github.com/libhal/arm-gnu-toolchain.git\n      compiler_profile: v1/arm-gcc-12.3\n      platform_profile_url: https://github.com/libhal/libhal-__platform__.git\n      platform_profile: v1/profile2\n    secrets: inherit\n</code></pre> <p>Key Checks:</p> <ul> <li>Library Checks: Ensures packaging in host mode, conducts host side tests,   verifies API documentation (Doxygen comments), and checks code formatting.</li> <li>Deployment Checks: Uses <code>deploy.yml</code> to simulate the deployment process   for all <code>build_type</code>s such as <code>Debug</code>, <code>MinSizeRel</code>, and <code>Release</code>, without a   specific <code>version</code> input for a dry run.</li> <li>Demo Application Checks: Ensures demo applications remain functional   after changes using <code>demo_builder.yml</code>. This script should specify the paths   to compiler and platform profiles, using these to download and build the   applications.</li> </ul> <p>Each <code>ci.yml</code> configuration should include these checks. If a package does not include demos, the demo check can be omitted, though it is generally recommended to include demos to demonstrate the library's capabilities.</p>"},{"location":"contributor_guide/arm_cortex_m_bringup/#platform-constants","title":"\ud83d\udcdc Platform Constants","text":"<p>Now we've reached the point where we can start modifying the C++ source code. The first area to start with is defining the <code>peripheral</code> and <code>irq</code> enumeration class constants. These outline the set of peripherals and interrupt requests that can be used on the platform.</p> <p>Here's a guide section for \"Peripheral Constants\" that you can use in your documentation. This section explains how to map peripheral identifiers to their respective power and clock control registers, tailored specifically for an API like the one you're designing for libhal.</p>"},{"location":"contributor_guide/arm_cortex_m_bringup/#peripheral-constants","title":"Peripheral Constants","text":"<p>In the libhal ecosystem, peripheral constants play a crucial role in the power and clock management APIs. These constants uniquely identify each peripheral and correspond directly to control bits in the power and clock registers. This design ensures efficient and straightforward management of peripheral power states and clock frequencies.</p>"},{"location":"contributor_guide/arm_cortex_m_bringup/#defining-peripheral-constants","title":"Defining Peripheral Constants","text":"<p>Peripheral constants are defined in an enumeration where each constant corresponds to a specific bit in a device's power or clock enable registers. This method allows direct manipulation of these registers using bit operations, which are both fast and memory-efficient.</p> <pre><code>namespace hal::your_platform {\n  /// List of each peripheral and their power on id number for this platform\n  enum class peripheral : std::uint8_t\n  {\n    // Examples\n    gpio = 0,\n    uart0 = 1,\n    spi1 = 2,\n    // More peripherals follow...\n    max, // Placeholder for the count of peripherals\n  };\n}\n</code></pre>"},{"location":"contributor_guide/arm_cortex_m_bringup/#mapping-to-power-registers","title":"Mapping to Power Registers","text":"<ol> <li> <p>Locate Power Registers: First, consult the power management section of    your microcontroller's user manual. Identify the registers responsible for    powering peripherals. These are often labeled as power control registers or    clock enable registers.</p> </li> <li> <p>Understand Register Layout: Registers typically control multiple    peripherals. Each bit in a register corresponds to the power state of one    peripheral. For instance, bit 0 might control the power for the GPIO    interface, bit 1 for the UART0, and so on.</p> </li> <li> <p>Designing the Enumeration: Define each peripheral in the enum class such    that the value of the enum matches the bit position in the power register.    For a microcontroller with two 32-bit power registers:</p> </li> <li>Peripherals controlled by the first register will have IDs 0 to 31.</li> <li> <p>Peripherals controlled by the second register will have IDs 32 to 63.</p> </li> <li> <p>Bitwise Operations: With each peripheral ID corresponding directly to a    bit position, you can toggle power by applying bitwise operations. For    example, to power on a peripheral, the operation would be:</p> </li> </ol> <pre><code>power_register |= (1 &lt;&lt; static_cast&lt;int&gt;(peripheral::uart0));\n</code></pre> <p>To power it off:</p> <pre><code>power_register &amp;= ~(1 &lt;&lt; static_cast&lt;int&gt;(peripheral::uart0));\n</code></pre>"},{"location":"contributor_guide/arm_cortex_m_bringup/#example-usage","title":"Example Usage","text":"<p>Consider a scenario where the ADC peripheral is mapped to bit 12 in the power control register. By defining the <code>adc</code> constant as 12 in the enum, you enable straightforward manipulation:</p> <ul> <li>Power On: <code>power_register |= (1 &lt;&lt; static_cast&lt;int&gt;(peripheral::adc));</code></li> <li>Check Power State: <code>bool isPowered = power_register &amp; (1 &lt;&lt; static_cast&lt;int&gt;(peripheral::adc));</code></li> <li>Power Off: <code>power_register &amp;= ~(1 &lt;&lt; static_cast&lt;int&gt;(peripheral::adc));</code></li> </ul>"},{"location":"contributor_guide/arm_cortex_m_bringup/#benefits","title":"Benefits","text":"<p>This mapping strategy ensures that your power and clock management API is both efficient and easy to use. It reduces the overhead of calculating bit masks and positions dynamically, leading to faster execution and cleaner code.</p> <p>This guide section aims to clarify the process of defining and using peripheral constants within the libhal framework, providing a structured approach to managing device resources effectively.</p> <p>Note</p> <p>Your microcontroller may use multiple bits or have a more complicated scheme to power control. If that is the case, then it is up to you to determine what is the best scheme for powering on peripheral on the device that driver and potentially users can utilize.</p>"},{"location":"contributor_guide/arm_cortex_m_bringup/#irq-constants","title":"IRQ Constants","text":"<p>It may be useful to understand how ARM Cortex M exceptions work. To learn these details, we'd highly recommend reading A Practical guide to ARM Cortex-M Exception Handling by Chris Coleman of Memfault.</p> <p>The maximum number of interrupts for Cortex-M series CPUs varies depending on the specific model within the Cortex-M family. Here is a breakdown of the maximum interrupt numbers for different Cortex-M series processors:</p> <ol> <li>Cortex-M0/M0+: Supports up to 32 external interrupts.</li> <li>Cortex-M3/M4/M7/M33/M35P: Supports up to 240 external interrupts.</li> <li>Cortex-M23: Supports up to 32 external interrupts.</li> </ol> <p>The exact number of interrupts available in a specific microcontroller will also depend on the chip and the specific features they have included. Consult the technical reference manual or datasheet for the mcu to get the precise number of interrupts supported and what they map to.</p> <pre><code>// The enum class type must always be `std::int16_t`, representing the\n// maximum number of IRQs a Cortex-M processor can support. This type is also\n// used for the input parameter that specifies the IRQ number.\nenum class irq : std::int16_t\n{\n  watchdog_timer = 0, // The first IRQ must always be zero\n  timer0 = 1,\n  timer1 = 2,\n  uart0 = 5,\n  uart1 = 6,\n  pwm1 = 9,\n  i2c0 = 10,\n  i2c1 = 11,\n  i2c2 = 12,\n  reserved0 = 13, // Fill gaps with reserved IRQs\n  spi0 = 14,\n  spi1 = 15,\n  pll0 = 16,\n  rtc = 17,\n  // ... Add the rest...\n  max, // The final entry must ALWAYS be \"max\"\n};\n</code></pre> <p>When referencing your user manual, look for the term NVIC, which stands for Nested Vector Interrupt Controller. This is a typical title in ARM MCU data sheets for where the interrupts IRQs are defined. The NVIC section in the manual typically includes IRQ numbers for each peripheral. Integrate these numbers into the enum class, assigning them as corresponding values. Additionally, you may encounter ISER, or Interrupt Set-Enable Register, which is the ARM designation for the register controlling interrupt enabling.</p>"},{"location":"contributor_guide/arm_cortex_m_bringup/#implementing-the-core-apis","title":"\ud83e\udde9 Implementing the core APIs","text":"<p>To be written.</p>"},{"location":"contributor_guide/board_library/","title":"Board Library Guide","text":"<p>A board library</p>"},{"location":"contributor_guide/dma_tutorial/","title":"\u23e9 DMA: Direct Memory Access Development Guide","text":"<p>DMA is a key feature in many microcontrollers. DMA allows data to be transferred from one location to another without the need for the CPU to perform the copy. This can be used to transfer large amounts of data from one place in memory to another place. It can also be used to automatically transfer data to a peripheral.</p> <p>As an example, lets consider an peripheral implementation of <code>hal::spi</code>. In order to write an spi driver without DMA, the CPU has to load a register used by the peripheral with data, then wait for the data to be shifted out of the device, before another byte can be put in. This means that the CPU has to baby sit the spi peripheral for each and every byte that is transferred. Whereas with DMA all that is needed is to tell the controller:</p> <ol> <li>The address of source data</li> <li>The address of the destination data</li> <li>The length of the transfer</li> <li>The word width of the source &amp; destination (8-bit, 16-bit, 32-bit)</li> <li>[optional] The endianness of the transfer</li> <li>And whether or not to increment the source and/or the destination address</li> </ol> <p>After that, just fire it off and it will do the work of loading the data register for you until it finishes. On completion, an interrupt will be invoked that indicates to the application that the transfer has completed.</p> <p>And that about it for simplicity. There are typically other configurations such as:</p> <ol> <li>Stride/stride-length: how many words lengths to skip in the input or output sequence. For example, if you had two dacs and PCM16 with L/R data alternating in the array like so, <code>u16l0, u16r0, u16l1, u16_r1, ..., u16_ln, u16_rn</code>, then the left side dac could start at address 0 with a stride length of 2 to skip the right side data. The same logic can be used to setup the right dac.</li> <li>Circular mode: DMA channels acts like a ring buffer allowing it to jump back to the start of the buffer when it reaches the end. This is very useful for <code>hal::serial</code> implementations.</li> <li>Burst size: allows a DMA controller to keep control over the bus for multiple cycles in order to ensure that data is sent without any break time.</li> </ol>"},{"location":"contributor_guide/dma_tutorial/#channels","title":"Channels","text":"<p>DMA controllers generally have a fixed set of DMA channels. These channels can operate independently, and allows for multiple transfer to occur at the \"same\" time.</p> <p>Channels can be used for a period of time or can be occupied for the lifetime of a driver. In general, DMA channels shouldn't be help for the lifetime of the driver as that would limit the number of available DMA channels that can be used by other drivers. An explicit exception to this is <code>hal::serial</code> which requires that its implementation is backed by a buffer. It is common to see uart implementations where there is only a single byte register for the uart data that is overwritten when the next byte is received. In order to not lose bytes, either an interrupt service routine is needed or DMA can be used fill up a buffer of bytes. Interrupts, although fast, still require cpu attention where as DMA handle this work for the cpu.</p> <p>The number of channels is limited and thus it is possible for there to be more drivers that require a DMA channel than DMA channels available. In these cases, the function for setting up DMA MUST busy wait until a DMA channel is made available before returning. In general, when designing an application, it is important to be mindful of the number of DMA channels a device has and how many drivers need channels. If the number of device drivers that use 1 or more DMA channels is greater than the number of channels, then the application developer must be mindful of this and design around this constraint.</p>"},{"location":"contributor_guide/dma_tutorial/#ram-blocks","title":"Ram blocks","text":"<p>When the cpu access memory from ram, it will use the device's address and data bus to make the transfer occur. DMA is no different. If DMA attempts to access the same resource as the cpu, then either the cpu or the DMA controller will stall until the other device is finished.</p> <p>A lot of devices will separate their memory into multiple ram blocks. The reason, with respect to DMA, is that having multiple ram blocks allow DMA to access one block of ram while the cpu works with ram in another ram block. If an application can design itself around this, it will help with the performance of the cpu and DMA when performing any sort of work.</p> <p>For example, lets say you want to make an MP3 player project. Gaps in audio can cause audio distortions and artifacts like clicks and pops. Gaps can be prevented by always ensuring that audio is making its way to the DAC. To ensure that there is always audio available to be streamed through the DAC a double buffering approach is used, where one buffer is actively being streamed out to the DAC and the other buffer is being filled with the new audio data. A dedicated thread is provided for audio decoding and audio streaming. The audio stream thread takes a buffer of audio data, sets up DMA for the transfer and then blocks its own thread. The audio decoder can now fill the other buffer with decoded mp3 data. Now consider this, lets assume that the buffers are both on the same RAM chip. In this case, whenever the DMA and cpu attempt to access the ram block, one of them will be stalled waiting for the other to finish. This can reduce performance and potentially result in audio artifacts. If these buffers are located in different ram blocks, then the DMA can access the ram block without stalling the CPU and vise-versa.</p> <p>Note that this also depends on if your system is a \"Single Bus System\" or a \"Multi Bus System\".</p> <ul> <li>Single Bus System: If there is only one data and address bus shared by all components, then even with multiple RAM blocks, access to these blocks is serialized through the single bus. In this case, the DMA and CPU cannot truly operate in parallel when accessing different blocks, as the single bus must arbitrate between them. This can still lead to stalls, though the overall impact might be reduced if the arbiter is efficient.</li> <li>Multiple Bus System: Some more complex systems might employ multiple buses (e.g., a separate bus for DMA and CPU). This architecture can allow truly concurrent access to different RAM blocks, significantly reducing or eliminating stalls because each master has its own path to memory.</li> </ul>"},{"location":"contributor_guide/dma_tutorial/#implementing-halplatformsetup_dma_transferdma","title":"Implementing <code>hal::&lt;platform&gt;::setup_dma_transfer(dma)</code>","text":"<p>All parts of this section require the user manual for your particular device.</p>"},{"location":"contributor_guide/dma_tutorial/#implementing-the-dma-structure","title":"Implementing the <code>dma</code> structure","text":"<p>The <code>dma</code> structure should include fields for every possible configuration that the dma.</p> <p>Warning</p> <p>Channel selection should not be a field in the dam structure. The channel selected should be determined by the <code>setup_dma_transfer</code> call based on which channels are available. Some dma devices provide a priority for each channel. The current philosophy is to ignore this priority system and simply provide the first channel that is available and if possible make the priority of all channels the same.</p> <p>Here is an example dma structure from <code>libhal-lpc40</code>:</p> <pre><code>enum class dma_transfer_type : std::uint8_t\n{\n  /// Flow Control: DMA controller\n  memory_to_memory = 0b000,\n  /// Flow Control: DMA controller\n  memory_to_peripheral = 0b001,\n  /// Flow Control: DMA controller\n  peripheral_to_memory = 0b010,\n  /// Flow Control: DMA controller\n  peripheral_to_peripheral = 0b011,\n  /// Flow Control: Destination Peripheral\n  peripheral_to_peripheral_dp = 0b100,\n  /// Flow Control: Destination Peripheral\n  memory_to_peripheral_dp = 0b101,\n  /// Flow Control: Source Peripheral\n  peripheral_to_memory_sp = 0b110,\n  /// Flow Control: Source Peripheral\n  peripheral_to_peripheral_sp = 0b111\n};\n\nenum class dma_transfer_width : std::uint8_t\n{\n  bit_8 = 0b000,\n  bit_16 = 0b001,\n  bit_32 = 0b010,\n};\n\nstruct dma\n{\n  void const volatile* source;\n  void volatile* destination;\n  std::size_t length;\n  // With every transfer, increment the address of the source location. Set to\n  // true to move forward through the length of the transaction. Set to false\n  // to keep the address the same for the entire length of the transfer. Set\n  // false is usually used when the address is a peripheral driver and the\n  // register you are reading from updates. Set to true when you want to\n  // transfer a sequence of data, an array, from ram to a peripheral or another\n  // area of memory.\n  bool source_increment;\n  // Same as source_increment but with the destination address.\n  bool destination_increment;\n  dma_transfer_width source_transfer_width;\n  dma_transfer_width destination_transfer_width;\n  dma_transfer_type transfer_type;\n};\n</code></pre> <p>Removed from the example above are the source and destination request number fields which are specific to the <code>lpc40</code> series. The burst count is also not present as well. If you're devices has such fields and are required to work, then add them to your data structure. Reading the above code should give you an idea of what a user must do in order to establish a dma transfer.</p> <p>Note the technique of using a strongly typed enumeration classes as binary control patterns. When making enumeration classes for each of your configuration parameters, it is wise to give the unique constants defined in the datasheet as the constants defined in the enum class. This way, the code for <code>setup_dma_transfer()</code> does not have to perform a translation from the value of the enum class to a value that the dma hardware can understand.</p> <p>When implementing the structure do the following:</p> <ol> <li>Open datasheet and search for the \"DMA\" section. Generally there will be a short synopsis about the device and what it supports.</li> <li>Read/skim the section on DMA. Locate the registers for controlling DMA and note what configurations it supports.</li> <li>Copy the dma structure above.</li> <li>Update the <code>dma_transfer_type</code> enum class fields with the set of values that match your device. If the enum class value codes cannot fit in std::uint8_t then the smallest size unsigned number that can fit your codes. If your device does not require or use such a construct, then simply delete the <code>dma_transfer_type</code> and <code>dma_transfer_type</code> field from the <code>dma</code> structure.</li> <li>Update <code>dma_transfer_width</code> enum class with the binary codes for your device's DMA transfer width.</li> <li>Add any other fields that are available for your dma besides channel selection.</li> </ol>"},{"location":"contributor_guide/dma_tutorial/#implementing-the-setup_dma_transfer-function","title":"Implementing the <code>setup_dma_transfer</code> function","text":"<p>The dma code should look like the following. Read the comments to get an idea of what is necessary to make this work.</p> <pre><code>constexpr std::size_t dma_channel_count = 8;\n\n// We need to provide memory to hold the callbacks for each dma channel. When\n// the dma transfer is finished, an interrupt will be invoked. That interrupt\n// handler will invoke the dma callback in this list.\nstd::array&lt;hal::callback&lt;void(void)&gt;, dma_channel_count&gt; dma_callbacks{\n  hal::cortex_m::default_interrupt_handler,\n  hal::cortex_m::default_interrupt_handler,\n  hal::cortex_m::default_interrupt_handler,\n  hal::cortex_m::default_interrupt_handler,\n  hal::cortex_m::default_interrupt_handler,\n  hal::cortex_m::default_interrupt_handler,\n  hal::cortex_m::default_interrupt_handler,\n  hal::cortex_m::default_interrupt_handler,\n};\n\nvoid handle_dma_interrupt() noexcept;\nvoid initialize_dma();\n\n// Atomic flag for acquiring the dma\nstd::atomic_flag dma_busy = ATOMIC_FLAG_INIT;\n\nvoid setup_dma_transfer(dma const&amp; p_configuration,\n                        hal::callback&lt;void(void)&gt; p_interrupt_callback)\n{\n  // Step 1.\n  //\n  // Compose the configuration, control, and whatever other registers you need\n  // to setup the dma.\n  auto const config_value = /* ... */;\n  auto const control_value = /* ... */;\n\n  // Step 2.\n  //\n  // Acquire atomic lock using spin lock\n  while (dma_busy.test_and_set(std::memory_order_acquire)) {\n    continue;  // spin lock\n  }\n\n  // Step 3.\n  //\n  // Initialize dma (this should be a one shot and should return early if the\n  // dma has already been initialized).\n  // Ensure that this call does not throw an exception, if so, use\n  initialize_dma();\n\n  // Step 4.\n  //\n  // Busy wait until a channel is available\n  while (true) {\n    // Step 5.\n    //\n    // Check for an available channel.\n    auto const available_channel = /* ... get available channel ... */\n\n    // Lets assume that if the channel number is above 8 then all channels are\n    // available.\n    if (available_channel &lt; 8) {\n      // Step 6.\n      //\n      // Copy callback to the callback array\n      dma_callbacks[available_channel] = p_interrupt_callback;\n\n      // Step 7.\n      //\n      // Get &amp; setup dma channel\n      auto* dma_channel = get_dma_channel_register(available_channel);\n\n      dma_channel-&gt;source_address =\n        reinterpret_cast&lt;std::uintptr_t&gt;(p_configuration.source);\n      dma_channel-&gt;destination_address =\n        reinterpret_cast&lt;std::uintptr_t&gt;(p_configuration.destination);\n      dma_channel-&gt;control = control_value;\n\n      // Step 8.\n      //\n      // Start dma transfer\n      dma_channel-&gt;config = config_value;\n      break;\n    }\n  }\n\n  // Step 9. Release lock\n  dma_busy.clear();\n}\n\n\nvoid initialize_dma()\n{\n  // You can use the fact that the dma is powered on to determine if the device\n  // has already been initialized.\n  if (is_on(peripheral::gpdma)) {\n    return;\n  }\n\n  // Otherwise power it on\n  power_on(peripheral::gpdma);\n\n  // Turn on interrupts\n  initialize_interrupts();\n\n  // enable the dma interrupt\n  hal::cortex_m::enable_interrupt(irq::dma, handle_dma_interrupt);\n\n  // Replace this code with what enables the dma\n  dma_reg-&gt;config = 1;\n}\n\nvoid handle_dma_interrupt() noexcept\n{\n  // The zero count from the LSB tells you where the least significant 1 is\n  // located. This allows the handled DMA interrupt callback to start at 0 and\n  // end at the last bit.\n  auto const status = std::countr_zero(dma_reg-&gt;interrupt_status);\n  auto const clear_mask = 1 &lt;&lt; status;\n\n  // NOTE: This may not be necessary on your device\n  dma_reg-&gt;interrupt_terminal_count_clear = clear_mask;\n  dma_reg-&gt;interrupt_error_clear = clear_mask;\n\n  // Call this channel's callback\n  dma_callbacks[status]();\n}\n</code></pre> <p>Take the above code and update the code to fit the needs of your device.</p>"},{"location":"contributor_guide/interface_design/","title":"\ud83d\udd17 Interface Design Philosophy","text":"<p>Interfaces are the foundation and building blocks of libhal. They are the \"A\" and \"L\" in HAL: hardware abstraction layer. They present a generalized ideal of a particular aspect of hardware or computing. For example and output pin represents a pin that can have its output voltage level state changed from a logical true or false value, which may be represented as a LOW voltage or HIGH voltage depending on the device.</p> <p>The following guidelines describe what should be kept in mind when creating an interface.</p> <p>Here is an example of some interfaces in libhal. It is recommended to take a look at these to get an idea of how the interfaces are written.</p> <ul> <li>hal::adc</li> <li>hal::serial</li> <li>hal::i2c</li> <li>hal::spi</li> <li>hal::can</li> <li>hal::dac</li> <li>hal::stream_dac</li> </ul>"},{"location":"contributor_guide/interface_design/#smallest-possible-v-table","title":"Smallest Possible v-table","text":"<p>When designing an interface aim to have the least number of virtual functions as possible.</p> <p>Why?</p> <p>Each virtual function in the interface will require a v-table entry (a pointer) in the v-table of each implementation of an interface. Each entry takes up space in the <code>.text</code> or <code>.rodata</code> sections of the binary. The more you have the more space is taken up.</p> <p>Consider:</p> <p>Combining APIs if it is possible. For example, lets consider <code>hal::output_pin</code> and <code>hal::i2c</code>.</p> <p><code>hal::output_pin</code> could have had a <code>::high()</code> and <code>::low()</code> API for setting the pins state. But these could easily be combined into a single API such as <code>::level(bool)</code> which accepts the state as an input parameter.</p> <p><code>hal::i2c</code> could have had <code>::write(...)</code>, <code>::read(...)</code>, and <code>::write_then_read(...)</code>. Instead, we have <code>transaction()</code> which can determine which of the 3 communication methods to use depending on whether or not the write and read buffers are supplied. If only one is available, then it will perform the respective <code>write</code> or <code>read</code> operation.</p>"},{"location":"contributor_guide/interface_design/#make-virtual-functions-pure-virtual","title":"Make virtual functions pure virtual","text":"<p>Interface API implementations are the responsibility of the implementer to be implemented.</p> <p>Why?</p> <p>In almost all cases, default behavior does not make sense.</p> <p>Consider:</p> <p>The exception to this rule is when a new virtual API is added to the end of the virtual API list. In order to be backwards compatible, the new API MUST be implemented with default behavior. Adding a new virtual API is a last resort and adding a new interface or an additional public class function should be preferred if it can solve the issue.</p>"},{"location":"contributor_guide/interface_design/#eliminate-viral-behavior","title":"Eliminate viral behavior","text":"<p>Another way to say this is, \"consider the overhead by the developer.\" This can be space &amp; time overhead in the program or simply the overhead required by the developer in order to use your API correctly.</p> <p>Why?</p> <p>Consider the following example of viral behavior through narrow contracts.</p> <p>Consider this line of code <code>dac.write(value)</code>. The input to the <code>write</code> function only accepts values from <code>0.0f</code> to <code>1.0f</code>. If value is greater or smaller than this then it is undefined behavior. The developer, to eliminate this undefined behavior they must do the following: <code>dac.write(std::clamp(value, 0.0f, 1.0f))</code>. This works. The concern here is that now all code that calls this function MUST add this clamp to ensure that the behavior is well defined OR have some other mechanism in place to ensure that value does no exceed the narrow contract of the <code>write</code> function. This becomes a vector for bugs and issues in the code. This viral behavior also leads to duplication of the same clamp code throughout the application developer's code as well as the interface implementation code. A well designed implementation would either check that the input is within the bounds allowed and potentially emit an error or clamp the value for the user. Now the clamp code is performed at the call site as well as the implementation. This is a waste of cycles and space.</p> <p>Consider:</p> <p>Consider what the caller of API will have to do in order to use your API correctly as well as the implementor of the API. In the example above, the solution to this viral behavior is to make the narrow contract into a wide contract where the public API clamps the input for the user, making all input (besides <code>NaN</code>), valid input. That way, the caller can be assured that their input will be clamped and the implementor can be assured that the value they get will ALWAYS be the expected values.</p> <p>Viral behavior can come in different forms that narrow and wide contracts, so great consideration must be taken when writing an API to eliminate such viral behavior.</p>"},{"location":"contributor_guide/interface_design/#private-virtual-functions","title":"Private virtual functions","text":"<p>Make virtual functions private. Make them callable via a public interface. Like so:</p> <pre><code>class my_interface {\npublic:\n  void foo() {\n    driver_foo();\n  }\n  bool bar() {\n    return driver_bar();\n  }\nprivate:\n  virtual void driver_foo() = 0;\n  virtual bool driver_bar() = 0;\n};\n</code></pre> <p>Why?</p> <p>If, in the event we need to modify the calling convention of a virtual API, we can do so by altering the public API.</p> <p>Consider:</p> <p><code>hal::motor</code> and <code>hal::dac</code> originally had narrow contracts which were widened to remove eliminate viral behavior. Previously <code>hal::motor</code> could only accept values from <code>-1.0f</code> to <code>+1.0f</code>. Anything beyond that would result in undefined behavior. This resulting in two large issues, viral behavior and undefined behavior. The first causes code bloat in terms of code size, and visual noise to the reader due to the code needed to clamp the input to motor's <code>power()</code> API. The second will cause potentially severe and hard to find bugs in the code which is unacceptable. To resolve this issue, the public API was updated to clamp the input from the caller before passing the info to the virtual API. This eliminates the need for the calling code to bounds check the value as well as eliminates the need for the virtual function implementation to bounds check the input value. This allows for backwards compatible updates to how a virtual API is called.</p> <pre><code>class motor\n{\npublic:\n  void power(float p_power)\n  {\n    auto clamped_power = std::clamp(p_power, -1.0f, +1.0f);\n    return driver_power(clamped_power);\n  }\n\nprivate:\n  virtual void driver_power(float p_power) = 0;\n};\n</code></pre> <p>Note</p> <p>This change is backwards API compatible and ABI compatible but may not be link time compatible, since there may be two definitions of the same class function between statically linked binaries.</p>"},{"location":"contributor_guide/interface_design/#consider-the-stack-ram-and-rom-requirements-of-an-api","title":"Consider the stack, ram and rom requirements of an API","text":"<p>Some API designs have the unwanted side effect of causing the user to provide or allocate a large buffer in order to operate. For example:</p> <pre><code>class big_buffer {\npublic:\n  struct big_struct {\n    std::array&lt;hal::byte, 10_kB&gt; buffer{};\n  };\nprivate:\n  virtual void driver_update(const big_struct&amp; p_buffer) = 0;\n};\n</code></pre> <p>Why?</p> <p>This can make interfaces and APIs hard to use in resource constrained systems. In the example above, in order to call the <code>driver_update</code> function, you need to pass it a buffer that takes up 10kB of ram. If this is allocated on the stack, it could easily overrun a thread's stack. If a device doesn't even have 10kB of ram then this API can never be called on the system. An example of this would be a display driver where an entire frame buffer is required in order to update the display.</p> <p>Consider:</p> <p>Consider if the input value needs to be so large? Can it be broken up into pieces? Can it implemented in another way that doesn't require a large amount of memory?</p>"},{"location":"contributor_guide/interface_design/#should-contain-no-member","title":"Should contain no member","text":"<p>Interfaces should only have public member functions and private virtual member functions. Nothing more.</p> <p>Why?</p> <p>The primary purpose of an interface is to define an abstract layer of communication between different parts of a program. Interfaces should ideally be agnostic of how their contracts are fulfilled. Including member fields implies a certain level of implementation detail that detracts from the abstraction.</p> <p>Adding fields to an interface can lead to tighter coupling between the interface and its implementations. This can complicate the design and increase the difficulty of changes in the future. Implementations are forced to manage state in a specific way, which can reduce flexibility in how they manage their internal states and behaviors.</p> <p>Consider:</p> <p>That you do not actually need to add a data member to the interface.</p>"},{"location":"contributor_guide/interface_design/#must-not-be-a-template","title":"Must not be a template","text":"<p>A templated interface is a class template that is also an interface like so:</p> <pre><code>template&lt;class PacketSize&gt;\nclass my_interface {\nprivate:\n  virtual void write(std::span&lt;const PacketSize&gt; p_payload) = 0;\n};\n</code></pre> <p>Why?</p> <p>The above example may seem like a great way to broaden an interface to an unlimited scale, but that is actually a problem. (insert reasons here).</p> <p>Template interfaces widen the scope and number of interfaces available in libhal in an unbounded way. This can result in additional v-tables for each interface implementation.</p> <p>Interface instances with different template types will not compatible with each other. Meaning an adaptor of sources would be needed to convert one to another.</p> <p>Consider:</p> <p>That this is not necessary. Consider that there exists a generic and specific implementation of an interface. Consider making two interfaces if a single interface would not suffice.</p>"},{"location":"contributor_guide/interface_design/#prefer-wide-api-contracts","title":"Prefer wide API contracts","text":"<p>A wide contract for an API means that an API can take any type of input for all of the input parameters sent to the API. Meaning that the API is well defined for all possible inputs that could be passed. That does not mean that the implementation of an API will accept all possible inputs. The API could throw an error if the input is beyond what it is capable of working with. But simply means that the API is well defined for the whole range of the inputs.</p> <p>Why?</p> <p>It helps eliminate viral behavior and tends to eliminate undefined behavior.</p> <p>Consider:</p> <p>The cost of an API having a wide contract? Would this result in viral behavior or eliminate it? Would it result in worse performance? Would it result in increased ram or increased rom utilization? Would it potentially save in all of these. If possible try and guarantee a wide contract if possible and only consider a narrow contract as a last resort. Explain in detail why a narrow contract was chosen, as those are vectors for bugs and undefined behavior.</p>"},{"location":"contributor_guide/interface_design/#do-not-break-abi","title":"Do NOT break ABI","text":"<p>ABI stands for Application Binary Interface. A breakage to an ABI is not easy for C++ or other languages to determine. A ABI break can come in many forms but it usually comes as a change between a version of code compiled previously and a version of code compiled now. Such a break can result in memory corruption, invalid input to a function and overall undefined behavior.</p> <p>Why?</p> <p>Don't do it! Its bad. But in all honesty, all hell breaks loose if we allow ABI breaks. If we MUST break ABI we MUST update the major version number of the library.</p> <p>Consider:</p> <p>With regards to interfaces, given the other rules, there is really only the following possible ABI breaking changes that can occur:</p> <ol> <li>Changing the return value of a virtual function</li> <li>Changing function calling convention.</li> <li>Reordering of virtual API within an interface.</li> <li>Reordering of members within a returned <code>struct</code> or <code>class</code>.</li> </ol> <p>These are not allowed due to how they affect how programs generate assembly for each function call. What we are allowed to do is the following:</p> <ol> <li>Add additional non-virtual public functions.</li> <li>Add additional overloads for public functions (we should <code>[[deprecate]]</code> old    APIs we know to be harmful).</li> <li>Add additional non-pure virtual APIs below the current set of virtual APIs    (should avoid this).</li> <li>Add additional fields to a settings <code>struct</code> that is passed by reference.</li> </ol>"},{"location":"contributor_guide/library_guides/","title":"\ud83d\udd39 Library Development Guide","text":"<p>Info</p> <p>Documentation coming soon...</p>"},{"location":"contributor_guide/organization/","title":"\ud83d\uddc3\ufe0f Organization","text":"<p>This section will explain the different parts/repos of libhal organization and ecosystem and how they are organized.</p>"},{"location":"contributor_guide/organization/#target-libraries","title":"Target Libraries","text":"<p>Target libraries depend on processor/OS libraries. The target libraries will include drivers for peripherals contained within their chip packages or, in the case of development boards and SBC (single board computers), these can also contain drivers external to the main chip. Processor/OS libraries contain APIs specific to those platforms for doing such things as handling interrupt service routines, initializing memory and more.</p> <pre><code>flowchart LR\n    libhal\n    subgraph processor/OS\n      libriscvmcu\n      libarmcortex\n      libhal-linux\n    end\n    subgraph arm-targets\n      liblpc40xx\n      libstm32f10x\n    end\n    subgraph riscv-targets\n      libgv32f10x\n      libsifive\n    end\n    subgraph linux-targets\n      libhal-linux-generic\n      libraspi\n    end\n\n    libhal--&gt;libhal-linux\n    libhal--&gt;libriscvmcu\n    libhal--&gt;libarmcortex\n\n    libarmcortex--&gt;liblpc40xx\n    libarmcortex--&gt;libstm32f10x\n\n    libriscvmcu--&gt;libgv32f10x\n    libriscvmcu--&gt;libsifive\n\n    libhal-linux--&gt;libhal-linux-generic\n    libhal-linux--&gt;libraspi</code></pre>"},{"location":"contributor_guide/organization/#device-libraries","title":"Device Libraries","text":"<p>Device driver libraries have a very simple relationship tree. Device libraries just need the libhal interfaces to work. The implementations of those interfaces will come from a target library in the application.</p> <pre><code>flowchart TD\n    libhal\n    libhal--&gt;libhal-soft\n    libhal--&gt;libmpu\n    libhal--&gt;libesp8266\n    libhal--&gt;libdrv\n    libhal--&gt;libwii\n    libhal--&gt;liballegro-micro\n    libhal--&gt;libdisplay-ssd\n    libhal--&gt;libled-apa-sk\n    libhal--&gt;libmatrix</code></pre>"},{"location":"contributor_guide/organization/#typical-application","title":"Typical Application","text":"<p>Lets consider an application such as \"Pong\". A game of pong where we use an LED matrix and two Wii controllers using the STM32F103 microcontroller.</p> <pre><code>flowchart LR\n    libhal--&gt;libmatrix--&gt;app\n    libhal--&gt;libarmcortex--&gt;libstm32f10x --&gt;app\n    libhal--&gt;libwii--&gt;app</code></pre> <p>The <code>conanfile.txt</code> would look something like this:</p> <pre><code>[requires]\nlibstm32f10x/1.1.0\nlibmatrix/1.0.2\nlibwii/1.5.2\n\n[generators]\nCMakeToolchain\nCMakeDeps\nVirtualRunEnv\n</code></pre>"},{"location":"contributor_guide/organization/#application-libraries","title":"Application Libraries","text":"<p>Application libraries are effectively applications with no specific dependency on a particular target. The point of a Application library is to deploy a fully fledged application, but with customizable drivers. For example, the pong game mentioned earlier doesn't require a wii controller or a LED matrix specifically. You could take a <code>hal::display</code> interface (not currently available) and some <code>pong::gamepad</code> interface defined by the Application library that the developer can implement themselves. Then the pong Application can take your display, gamepad and additional information like, \"paddle size\" and \"font size\" and use it to generate a game of pong. The developer gets the opportunity to choose which parts they want for each. Maybe they want a very large TFT display or they want to use a LED matrix. Maybe they want to use a Stadia controller or maybe they want to make a controller out of capacitive sensors and bananas. The choices are endless.</p>"},{"location":"contributor_guide/organization/#finding-drivers","title":"\ud83d\udd0d Finding Drivers","text":"<p>To find drivers you can look in three locations</p> <ul> <li>libhal organization</li> <li>conan center index</li> <li>libhal driver index \u274c</li> </ul> <p>Example</p> <p>libhal driver index is not available currently and is key to finding drivers around the ecosystem.</p> <p>Search for the name of the device or target you are interested with with the prefix <code>lib</code> in front of it. Try not to be too specific though. For example, the <code>stm32f103c8t6</code> microcontroller target library drivers will be in the package <code>libstm32f10x</code>. The <code>mpu6050</code> accelerometer will be in <code>libmpu</code>.</p>"},{"location":"contributor_guide/organization/#reference-material","title":"\ud83d\udcd1 Reference Material","text":"<p>Reference material can be found in the <code>datasheets/</code> and <code>schematic/</code> folders. The layout of these directories match that <code>demos/</code>, where the first layer of folders are named after the microcontroller or board they describe.</p> <p>These folders are updated with relevant documents for easy access for our developers and contributors.</p>"},{"location":"contributor_guide/philosophy/","title":"\ud83d\udcdc Design Philosophy","text":"<p>These are the core design tenets that <code>libhal</code> and libraries extending it must seek to achieve with every design choice, line written, and architecture change made.</p>"},{"location":"contributor_guide/philosophy/#d1-multi-targeted","title":"D.1 Multi Targeted","text":"<p><code>libhal</code> and the libraries that extend it, should work anywhere. So long as the appropriate compiler or cross compiler is used, the driver should do as it is intended. The exception is <code>target</code> libraries which are designated to execute for a particular target. Even so, those <code>target</code> libraries MUST be unit testable on any host machine.</p>"},{"location":"contributor_guide/philosophy/#d2-light-weight","title":"D.2 Light Weight","text":"<p><code>libhal</code> should keep its interfaces and utility code light weight, meaning such things do not allocate, and if they do only once, do not perform long/length copies, unless a copy was the desired operation,</p>"},{"location":"contributor_guide/philosophy/#d3-general","title":"D.3 General","text":"<p><code>libhal</code> interfaces should be general, meaning that they do not include APIs, or configuration settings that are uncommon in most targets or specific to a particular target.</p>"},{"location":"contributor_guide/philosophy/#d4-minimalist","title":"D.4 Minimalist","text":"<p><code>libhal</code> aims to be as simple as possible and no simpler. Interfaces, utility functions, and libraries should be straight forward for most programmers to understand with added complexity only when it is necessary and no other options exist.</p>"},{"location":"contributor_guide/philosophy/#d5-safe-reliable","title":"D.5 Safe &amp; Reliable","text":"<p><code>libhal</code> and its style guide aim to use patterns, techniques, and documentation to help reduce safety issues and improve reliability.</p>"},{"location":"contributor_guide/philosophy/#d6-tested-testable","title":"D.6 Tested &amp; Testable","text":"<p><code>libhal</code> code should be as testable and unit tested.</p>"},{"location":"contributor_guide/philosophy/#d7-compiled-quickly","title":"D.7 Compiled Quickly","text":"<p><code>libhal</code> code should build fast and eliminate/replace any unnecessary dependencies that cause compile times to be long.</p>"},{"location":"contributor_guide/philosophy/#d8-portable","title":"D.8 Portable","text":"<p><code>libhal</code> code should not require or depend on any OS or target specific code or behaviors. <code>libhal</code> is designed to work anywhere and should not rely on OS.</p>"},{"location":"contributor_guide/style/","title":"\ud83c\udfa8 Style Guide","text":""},{"location":"contributor_guide/style/#s0-code-guidelines","title":"S.0 Code Guidelines","text":"<p>All guides follow the C++ Core Guidelines.</p>"},{"location":"contributor_guide/style/#s1-formatting","title":"S.1 Formatting","text":"<ul> <li>Code shall follow libhal's   <code>.clang-format</code>   file, which uses the Mozilla C++ style format as a base with some adjustments.</li> <li>Code shall follow libhal's   <code>.naming.style</code>   file, which is very similar to the standard library naming convention:</li> <li>CamelCase for template parameters.</li> <li>CAP_CASE for MACROs (avoid MACROs in general).</li> <li>lowercase snake_case for everything else.</li> <li>prefix <code>p_</code> for function parameters.</li> <li>prefix <code>m_</code> for private/protected class member.</li> <li>Refrain from variable names with abbreviations where it can be helped. <code>adc</code>,   <code>pwm</code>, and <code>i2c</code> are extremely common so it is fine to leave them as   abbreviations. Most people know the abbreviations more than the words that   make them up. But words like <code>cnt</code> should be <code>count</code> and <code>cdl</code> and <code>cdh</code>   should be written out as <code>clock_divider_low</code> and <code>clock_divider_high</code>.   Registers do get a pass if they directly reflect the names in the data sheet   which will make looking them up easier in the future.</li> <li>Use <code>#pragma once</code> as the include guard for headers.</li> <li>Every file must end with a newline character.</li> <li>Every line in a file must stay within a 80 character limit.</li> <li>Exceptions to this rule are allowed. Use <code>// NOLINT</code> in these cases.</li> <li>Radix for bit manipulation:</li> <li>Only use binary (<code>0b1000'0011</code>) or hex (<code>0x0FF0</code>) for bit manipulation.</li> <li>Never use decimal or octal as this is harder to reason about for most     programmers.</li> <li>Every public API must be documented with the doxygen style comments (CI will   ensure that every public API is documented fully).</li> <li>Include the C++ header version of C headers such as <code>&lt;cstdint&gt;</code> vs   <code>&lt;stdint.h&gt;</code>.</li> </ul>"},{"location":"contributor_guide/style/#s2-refrain-from-performing-manual-bit-manipulation","title":"S.2 Refrain from performing manual bit manipulation","text":"<p>Use <code>hal::bit_modify</code> from <code>libhal-util</code> library to perform bitwise operations operations.</p>"},{"location":"contributor_guide/style/#s3-refrain-from-using-macros","title":"S.3 Refrain from using MACROS","text":"<p>Only use macros if something cannot be done without using them. Usually macros can be replaced with <code>constexpr</code> or const variables or function calls. A case where macros are the only way is for HAL_CHECK() since there is no way to automatically generate the boiler plate for returning if a function returns and error in C++ and thus a macro is needed here to prevent possible mistakes in writing out the boilerplate.</p> <p>Only use preprocessor <code>#if</code> and the like if it is impossible to use <code>if constexpr</code> to achieve the same behavior.</p>"},{"location":"contributor_guide/style/#s4-never-include-c-iostream-libraries","title":"S.4 Never include C++ <code>&lt;iostream&gt;</code> libraries","text":"<p>Applications incur an automatic 150kB space penalty for including any of the ostream headers that also statically generate the global <code>std::cout</code> and the like objects. This happens even if the application never uses any part of <code>&lt;iostream&gt;</code> library. <code>&lt;iostream&gt;</code> can be used in libraries that will only be used for host side testing.</p>"},{"location":"contributor_guide/style/#s5-refrain-from-memory-allocations","title":"S.5 Refrain from memory allocations","text":"<p>Interfaces and drivers should refrain from APIs that force memory allocations or implementations that allocate memory from heap. This means avoiding STL libraries that allocate such as <code>std::string</code> or <code>std::vector</code>.</p> <p>Many embedded system applications, especially the real time applications, do not allow dynamic memory allocations. There are many reasons for this that can be found MISRA C++ and AutoSAR.</p>"},{"location":"contributor_guide/style/#s6-drivers-should-not-log-to-stdout-or-stdin","title":"S.6 Drivers should not log to STDOUT or STDIN","text":"<p>Peripheral drivers must NOT log to stdout or stderr. This means no calls to</p> <ul> <li><code>std::printf</code></li> <li><code>std::cout</code></li> <li><code>std::print</code> (C++26's version of print based on <code>std::format</code>)</li> </ul> <p>Consider using the file I/O libraries in C, C++, python or some other language. Would you, as a developer, ever imagine that opening, reading, writing, or closing a file would (write?) to your console? Especially if there did not exist a way to turn off logging. Most users would be very upset as this would not seem like the role of the file I/O library to spam the console. This gets even worse if a particular application has thousands of files and each operation is logging.</p> <p>The role of logging should be held by the application developer, not their drivers or helper functions, unless the purpose of the helper functions or driver is to write to console.</p>"},{"location":"contributor_guide/style/#s7-drivers-should-not-purposefully-halt-or-terminate-the-application","title":"S.7 Drivers should not purposefully halt OR terminate the application","text":"<p>Drivers are not entitled to halt the execution of the application and thus any code block that would effectively end or halt the execution of the program without giving control back to the application are prohibited.</p> <p>As an example drivers should never call:</p> <ul> <li><code>std::abort()</code></li> <li><code>std::exit()</code></li> <li><code>std::terminate()</code></li> <li>any of their variants</li> </ul> <p>This includes placing an infinite loop block in a driver.</p> <p>An application should have control over how their application ends. A driver should report severe errors to the application and let the application decide the next steps. If a particular operation cannot be executed as intended, then an appropriate <code>hal::exception</code> type should be thrown.</p>"},{"location":"contributor_guide/style/#s8-drivers-should-not-pollute-the-global-namespace","title":"S.8 Drivers should not pollute the global namespace","text":"<p>All drivers must be within the <code>hal</code> namespace or within their own bespoke namespace.</p> <p>Inclusion of a C header file full of register map structures is not allowed as it pollutes the global namespace and tends to result in name collisions.</p> <p>Care should be taken to ensure that the <code>hal</code> namespace is also as clean as possible by placing structures, enums, const data, and any other symbols into the driver's class's namespace like so:</p> <pre><code>namespace hal::target\n{\nclass target {\n  struct register_map {\n    std::uint32_t control1;\n    std::uint32_t control2;\n    std::uint32_t data;\n    std::uint32_t status;\n    // ..\n  };\n\n  struct control1_register {\n    static constexpr auto channel_enable = hal::bit::range::from&lt;0, 7&gt;();\n    static constexpr auto peripheral_enable = hal::bit::range::from&lt;8&gt;();\n    // ...\n  };\n\n  // ...\n};\n}\n</code></pre>"},{"location":"contributor_guide/style/#s9-interface-should-follow-the-public-private-api-scheme","title":"S.9 Interface should follow the public private API Scheme","text":"<p>See private virtual method for more details. Rationale can be found within that link as well.</p>"},{"location":"contributor_guide/style/#s10-avoid-using-bool-as","title":"S.10 Avoid using <code>bool</code> as:","text":""},{"location":"contributor_guide/style/#s101-an-object-member","title":"S.10.1 an object member","text":"<p><code>bool</code> has very poor information density and takes up 8-bits per entry. If only one <code>bool</code> is needed, then a bool is a fine object member. If multiple <code>bool</code>s are needed, then use a <code>std::bitset</code> along with static <code>constexpr</code> index positions in order to keep the density down to the lowest amount possible.</p>"},{"location":"contributor_guide/style/#s102-a-parameter","title":"S.10.2 a parameter","text":"<p>See the article \"Clean code: The curse of a boolean parameter\" for details as to why <code>bool</code> parameters are awful.</p> <p><code>bool</code> is fine if it is the only parameter and it acts as a lexical switch, for example:</p> <pre><code>// This is fine because it reads as set \"LED\" voltage \"level\" to \"FALSE\"\nled.level(false);\n// This is fine because it reads as set \"LED\" voltage \"level\" to \"TRUE\"\nled.level(true);\n</code></pre>"},{"location":"contributor_guide/style/#s11-integrating-third-party-libraries-by-source","title":"S.11 Integrating third party libraries by source","text":"<p>In general, third party libraries should NOT be integrated into a library by source. It should be depended upon using a package manager. But in some cases third party libraries must be included by source. In these cases, the third party libraries should be committed into a project, without modifications, into the <code>include/&lt;library_name&gt;/third_party</code> directory. After that commit, the third party libraries can be used by and integrated into the library code base, in a following commit.</p> <p>If a third party library is modified, that library must have a section at the top of the file with the following description:</p> <pre><code>/**\n * [libhal] modifications to this file are as follows:\n *\n *    1. mod 1\n *    2. mod 2\n *    3. mod 3\n *    4. mod 4\n */\n\n/**\n * &lt;LICENSE GOES HERE!&gt;\n */\n</code></pre> <p>Care must be taken to ensure that third party libraries do not conflict with the licenses of libhal libraries and permit direct integration as well as modification.</p> <p>Rationale: Makes keeping track of changes and the history of files easier to manage.</p>"},{"location":"contributor_guide/style/#s12-avoid-stdatomic","title":"S.12 Avoid <code>std::atomic</code>","text":"<p>Avoid using <code>std::atomic</code> in device libraries due to portability issues across architectures. Device libraries are designed to work across architectures meaning they cannot depend on platform specific constructs like this.</p> <p>Note that <code>target</code> and <code>processor</code> libraries are allowed to use <code>std::atomic</code> if it is available with their cross compiler and toolchain. In this case, the we can know which target devices the software is running on, either the target itself, which we already know can support it, or on a host machine for unit testing, which is very likely to have a compiler that supports atomics.</p>"},{"location":"contributor_guide/style/#s13-avoid-thread","title":"S.13 Avoid <code>&lt;thread&gt;</code>","text":"<p>Embedded system compilers tend to not provide an implementation of <code>&lt;thread&gt;</code> because the choice of which threading model or multi-threading operating system is left to the developer.</p> <p>In general, <code>#include &lt;thread&gt;</code> will almost never work when cross compiling.</p>"},{"location":"contributor_guide/upgrade_to_libhal_3_device_library/","title":"Upgrading a Device Library from libhal 2.x.y to 3.x.y","text":"<p>This guide is for device, utility, RTOS, or any other cross platform libraries that need to be ported from libhal 2.x.y to 3.x.y.</p> <p>The upgrade to libhal 3.x.y is a breaking change for everything so their major number for your library will need to be updated. So if the previous version was 2.1.5, then its new version is 3.0.0. If the version was 3.0.1, then the next is 4.0.0. Remember that version for later because everywhere in this code with where you see <code>3.0.0</code> replace it with the correct version for your library.</p>"},{"location":"contributor_guide/upgrade_to_libhal_3_device_library/#1-set-the-ciyml-to-the-following","title":"(1) Set the <code>ci.yml</code> to the following","text":"<pre><code>name: \u2705 CI\n\non:\n  workflow_dispatch:\n  pull_request:\n  push:\n    branches:\n      - main\n  schedule:\n    - cron: \"0 12 * * 0\"\n\njobs:\n  ci:\n    uses: libhal/ci/.github/workflows/library_check.yml@5.x.y\n    secrets: inherit\n\n  deploy_cortex-m4f_check:\n    uses: libhal/ci/.github/workflows/deploy.yml@5.x.y\n    with:\n      arch: cortex-m4f # Replace with correct architecture\n      os: baremetal\n      compiler: gcc\n      compiler_version: 12.3\n      compiler_package: arm-gnu-toolchain\n    secrets: inherit\n\n  demo_check:\n    uses: libhal/ci/.github/workflows/demo_builder.yml@5.x.y\n    with:\n      compiler_profile_url: https://github.com/libhal/arm-gnu-toolchain.git\n      compiler_profile: v1/arm-gcc-12.3\n      platform_profile_url: https://github.com/libhal/libhal-lpc40.git\n      platform_profile: v2/lpc4078 # replace if you are not using lpc4078\n    secrets: inherit\n</code></pre> <p>This will handle everything you need for checking your library conforms to the libhal standards.</p>"},{"location":"contributor_guide/upgrade_to_libhal_3_device_library/#2-add-a-release-yaml-file-with-the-next-version-of-the-library","title":"(2) Add a release yaml file with the next version of the library","text":"<p>The new scheme for launching versions is to have a workflow dispatch action file. This action must be manually invoked to launch a version. This allows for more control over which versions are deployed to the server as well as launching revisions if a dependency has a bug but a client cannot upgrade the library version.</p> <p>The file name in the <code>.github</code> file will be <code>X.0.0.yml</code> where X is the next major version number.</p> <pre><code>name: \ud83d\ude80 Deploy 3.0.0 # Replace with the next major version\n\non:\n  workflow_dispatch:\n\njobs:\n  deploy:\n    uses: libhal/ci/.github/workflows/deploy_all.yml@5.x.y\n    with:\n      version: 3.0.0 # Replace with the next major version must match the title\n    secrets: inherit\n</code></pre>"},{"location":"contributor_guide/upgrade_to_libhal_3_device_library/#3-refactor-library-conanfilepy-found-at-the-root-of-the-repo","title":"(3) Refactor library <code>conanfile.py</code> (found at the root of the repo)","text":"<p>Replace the contents of the file with the data below:</p> <pre><code># Copyright 2024 Khalil Estell\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom conan import ConanFile\n\nrequired_conan_version = \"&gt;=2.0.14\"\n\n\nclass libhal___device___conan(ConanFile):\n    name = \"libhal-__device__\"\n    license = \"Apache-2.0\"\n    homepage = \"https://github.com/libhal/libhal-__device__\"\n    description = (\"... fill this out ...\")\n    topics = (\"... fill this out ...\")\n    settings = \"compiler\", \"build_type\", \"os\", \"arch\"\n\n    python_requires = \"libhal-bootstrap/[^1.0.0]\"\n    python_requires_extend = \"libhal-bootstrap.library\"\n\n    def requirements(self):\n        bootstrap = self.python_requires[\"libhal-bootstrap\"]\n        bootstrap.module.add_library_requirements(self)\n\n    def package_info(self):\n        self.cpp_info.libs = [\"libhal-__device__\"]\n        self.cpp_info.set_property(\"cmake_target_name\", \"libhal::__device__\")\n</code></pre> <p>Replace every instance of <code>__device__</code> with the name of the library.</p> <pre><code>    description = (\"... fill this out ...\")\n    topics = (\"... fill this out ...\")\n</code></pre> <p>Fill the <code>description</code> and <code>topics</code> sections based on what they were before.</p>"},{"location":"contributor_guide/upgrade_to_libhal_3_device_library/#4-update-cmakeliststxt","title":"(4) Update CMakeLists.txt","text":"<p>Remove the following packages and link libraries from your CMake file. These are now automatically linked against your library when you use <code>libhal_test_and_make_library</code>.</p> <pre><code>  PACKAGES\n  libhal\n  libhal-util\n\n  LINK_LIBRARIES\n  libhal::libhal\n  libhal::util\n</code></pre>"},{"location":"contributor_guide/upgrade_to_libhal_3_device_library/#5-update-test_packagecmakeliststxt","title":"(5) Update <code>test_package/CMakeLists.txt</code>","text":"<p>Replace it with this, update <code>__device__</code> to the correct library name:</p> <pre><code># Copyright 2024 Khalil Estell\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\ncmake_minimum_required(VERSION 3.15)\nproject(test_package LANGUAGES CXX)\n\nfind_package(libhal-__device__ REQUIRED CONFIG)\n\nadd_executable(${PROJECT_NAME} main.cpp)\ntarget_include_directories(${PROJECT_NAME} PUBLIC .)\ntarget_compile_features(${PROJECT_NAME} PRIVATE cxx_std_20)\ntarget_link_libraries(${PROJECT_NAME} PRIVATE libhal::__device__)\n</code></pre>"},{"location":"contributor_guide/upgrade_to_libhal_3_device_library/#5-update-test_packageconanfilepy","title":"(5) Update <code>test_package/conanfile.py</code>","text":"<p>Replace it with this:</p> <pre><code># Copyright 2024 Khalil Estell\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom conan import ConanFile\n\n\nclass TestPackageConan(ConanFile):\n    settings = \"os\", \"arch\", \"compiler\", \"build_type\"\n\n    python_requires = \"libhal-bootstrap/[^1.0.0]\"\n    python_requires_extend = \"libhal-bootstrap.library_test_package\"\n\n    def requirements(self):\n        self.requires(self.tested_reference_str)\n</code></pre>"},{"location":"contributor_guide/upgrade_to_libhal_3_device_library/#5-replace-demosconanfilepy","title":"(5) Replace <code>demos/conanfile.py</code>","text":"<p>Replace it with the following:</p> <pre><code># Copyright 2024 Khalil Estell\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom conan import ConanFile\n\n\nclass demos(ConanFile):\n    python_requires = \"libhal-bootstrap/[^1.0.0]\"\n    python_requires_extend = \"libhal-bootstrap.demo\"\n\n    def requirements(self):\n        bootstrap = self.python_requires[\"libhal-bootstrap\"]\n        bootstrap.module.add_demo_requirements(self)\n        # Change 3.0.0 to the correct major release number\n        # Replace __device__ with the name of the library\n        self.requires(\"libhal-__device__/[^3.0.0 || latest]\")\n</code></pre> <p>Info</p> <p>You may be wonder why we have <code>|| latest</code> for the version range. \"latest\" is the version used by CI to ensure that the demo builds using the \"latest\" version built on the CI's virtual machine. It isn't a valid libhal version for a library, so we can use it for CI purposes.</p>"},{"location":"contributor_guide/upgrade_to_libhal_3_device_library/#6-replace-demoscmakeliststxt","title":"(6) Replace <code>demos/CMakeLists.txt</code>","text":"<pre><code># Copyright 2024 Khalil Estell\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\ncmake_minimum_required(VERSION 3.20)\n\nproject(demos LANGUAGES CXX)\n\nlibhal_build_demos(\n    DEMOS\n    demo1\n    demo2\n    # Add more demos if applicable\n\n    PACKAGES\n    libhal-__device__\n\n    LINK_LIBRARIES\n    libhal::__device__\n)\n</code></pre> <p><code>libhal</code>, <code>libhal-util</code>, and <code>libhal-__platform__</code> (where <code>__platform__</code> is the platform defined in your platform profile file), are automatically searched for and linked into your project, so you only need to link in your library and any others that are needed for the demos to build correctly.</p> <p>Add any other additional packages that are linked in beyond the <code>__device__</code>.</p> <p>Replace <code>demo1</code> and <code>demo2</code> with the correct demo names in the <code>applications</code> directory. Demos have the name <code>demo_name.cpp</code>, and the name you put in the <code>DEMOS</code> list is their name without the <code>.cpp</code> extension.</p>"},{"location":"contributor_guide/upgrade_to_libhal_3_device_library/#7-refactor-code","title":"(7) Refactor code","text":"<p>This is where the fun bit comes in. Now that all of the interfaces have been modified, Each header and cpp file that uses them will need to fixed up.</p> <ol> <li>For every api that inherits an interface, update the APIs for derived class    to match the new interface.</li> <li>Replace factory functions with constructors (make functions should stay the    same as they were before).</li> <li>Use exceptions rather than <code>return hal::new_error()</code>. Make sure to use    <code>hal::safe_throw</code> instead of <code>throw</code> directly. To know which exception to    throw you MUST read the <code>libhal/error.hpp</code> file and determine which    exception fits the best. If none of them seem to fit, join the discord and    ask about it in the \"discussions\" channel. Also consider leaving an issue on the <code>libhal/libhal</code> repo about the error you'd like to add to the list or if you aren't sure. See <code>std::errc</code> for the list of error codes we use to make our exceptions.</li> </ol>"},{"location":"contributor_guide/upgrade_to_libhal_3_device_library/#8-refactor-tests_package","title":"(8) Refactor <code>tests_package/</code>","text":"<p>Update the test package to use the newly refactored code. If there is nothing in the <code>main.cpp</code> besides including a header file, then leave it as is.</p>"},{"location":"contributor_guide/upgrade_to_libhal_3_device_library/#8-refactor-tests","title":"(8) Refactor tests","text":"<p>This shouldn't be too hard. Apply the same techniques used in refactor code. Be sure to look at <code>libhal-util</code>, <code>libhal-soft</code> and <code>libhal-mock</code> to get an idea of what is needed for the refactor. Remove all of the checks for success status such as:</p> <pre><code>  expect(!result1);\n  expect(!result2);\n  expect(!result3);\n  expect(!result4);\n  expect(!result5);\n\n  // or\n\n  expect(bool{ result1 });\n  expect(bool{ result2 });\n  expect(bool{ result3 });\n  expect(bool{ result4 });\n  expect(bool{ result5 });\n</code></pre> <p>To test for a thrown exception use the following pattern:</p> <pre><code>  expect(throws&lt;hal::argument_out_of_domain&gt;([&amp;]() {\n    test_subject_object.function_that_will_throw(input_that_will_cause_throw);\n  }));\n</code></pre> <p><code>throws</code> checks if an exception of a particular type is thrown and will catch it and return an expectation value. It takes a lambda or any other callable, that invokes the throwing behavior. If the calls do not throw an exception then throws fails and reports that to the user.</p>"},{"location":"contributor_guide/upgrade_to_libhal_3_device_library/#7-refactor-test_package","title":"(7) Refactor test_package","text":"<p>Remove any code needed for boost.</p> <pre><code>namespace boost {\nvoid throw_exception(std::exception const&amp; e)\n{\n  hal::halt();\n}\n}  // namespace boost\n</code></pre> <p>Remove anything that is target specific in the test package such as cross compile flags. Those flags MUST be removed and only handled by the compiler.</p> <p>Update the test package to make the new APIs.</p>"},{"location":"contributor_guide/upgrade_to_libhal_3_device_library/#questions","title":"Questions?","text":"<p>If you have any questions please post them in the <code>discussions</code> channel in discord. Make sure to make it a thread so the main channel is not overwhelmed with messages.</p>"},{"location":"education/actuators/","title":"Basics of Actuators","text":"<p>Coming soon...</p>"},{"location":"education/adc/","title":"ADC: Analog to Digital Converter","text":"<p>Coming soon...</p>"},{"location":"education/architecture/","title":"Microcontroller Architecture","text":"<p>Coming soon...</p>"},{"location":"education/bitmasking/","title":"The Art of Bit Masking","text":"<p>Coming soon...</p>"},{"location":"education/canbus/","title":"CAN BUS: Controller Area Network Bus","text":"<p>Coming soon...</p>"},{"location":"education/dac/","title":"DAC: Digital to Analog Convert","text":"<p>Coming soon...</p>"},{"location":"education/dma/","title":"DMA: Direct Memory Access","text":"<p>Coming soon...</p>"},{"location":"education/embedded_systems/","title":"Introduction to Embedded Systems","text":"<p>Coming soon...</p>"},{"location":"education/gpio/","title":"GPIO: General Purpose Input/Output","text":"<p>Coming soon...</p>"},{"location":"education/i2c/","title":"I2C: Inter-Integrated Circuit","text":"<p>Coming soon...</p>"},{"location":"education/pwm/","title":"PWM: Pulse Width Modulation","text":"<p>Coming soon...</p>"},{"location":"education/rtos/","title":"RTOS: Real time Operating Systems","text":"<p>Coming soon...</p>"},{"location":"education/sensors/","title":"Basics of Sensors","text":"<p>Coming soon...</p>"},{"location":"education/spi/","title":"SPI: Serial Peripheral Interface","text":"<p>Coming soon...</p>"},{"location":"education/tbd/","title":"To be determined","text":"<p>This page is just a place holder for additional content. This page will always be here because there will always be more subjects to discuss when it comes to embedded systems.</p>"},{"location":"education/timers_and_counters/","title":"Timers &amp; Counters","text":"<p>Coming soon...</p>"},{"location":"education/uart/","title":"UART: Universal Asynchronous Receiver/Transmitter","text":"<p>Coming soon...</p>"},{"location":"project_information/about/","title":"About","text":"<p>The world of embedded systems is written almost entirely in C and C++. More and more of the embedded world move away from C and towards C++. This has to do with the many benefits of C++ such as type safety, compile time features, meta-programming, multi-paradigm and much more. When these features are used correctly, they can result in smaller binary sizes and higher performance code than in C.</p> <p>But a problem that embedded C++ software suffers is that there isn't a consistent and common API for embedded libraries. Looking around, you will find that each hardware vendor has their own set of libraries and tools for their specific products. If you write a driver on top of their libraries, you will find that your code will only work for that specific platform/product. In some cases you may also be limited to just their toolchain. You as the developer are locked in to this one specific setup. And if you move to another platform, you must do the work of rewriting all of your code again.</p> <p>libhal seeks to solve this issue by creating a set of generic interfaces for embedded system concepts such as serial communication (UART), analog to digital conversion (ADC), inertial measurement units (IMU), pulse width modulation (PWM) and much more. The advantage of building a system on top of libhal is that higher level drivers can be used with any target platform whether it is a stm32, a nxp micro controller, a RISC-V, or is on an embedded linux.</p> <p>This project is inspired by the work of Rust's embedded_hal and follows many of the same design goals.</p> <p>libhal's design goals:</p> <ol> <li>Serve as a foundation for building an ecosystem of platform agnostic drivers.</li> <li>Must abstract away device specific details like registers and bitmaps.</li> <li>Must be generic across devices such that any platform can be supported.</li> <li>Must be minimal for boosting performance and reducing size costs.</li> <li>Must be composable such that higher level drivers can build on top of these.</li> <li>Be accessible through package mangers so that developers can easily pick and    choose which drivers they want to use.</li> </ol>"},{"location":"project_information/about/#software-copyrights","title":"Software Copyrights","text":"<p>This source code is licensed under the Apache License 2.0 as described in the LICENSE file.</p>"},{"location":"project_information/about/#third-party-library-licenses","title":"Third Party Library Licenses","text":"<ul> <li>tl-function-ref/1.0.0, CC0</li> </ul>"},{"location":"project_information/status/","title":"\ud83d\udfe2 Library Status \ud83d\udd34","text":"<p>Repo</p> <p>CI State</p> <p>Latest Version</p> libhal/libhal-arm-mcu libhal/libhal-iot libhal/libhal-sensor libhal/libhal-expander libhal/libhal-actuator libhal/libhal-display libhal/libhal-mock libhal/libhal-soft libhal/libhal-util libhal/libhal libhal/libhal-storage libhal/libhal-canrouter libhal/libhal-micromod libhal/libhal-input libhal/libhal-freertos"},{"location":"user_guide/debugging/","title":"\ud83c\udfaf Debugging Code with PyOCD","text":""},{"location":"user_guide/debugging/#introduction","title":"Introduction","text":"<p>PyOCD is an open-source Python package for programming and debugging Arm Cortex-M microcontrollers using CMSIS-DAP. It's a highly flexible and easy-to-use tool, but it's important to note that it only supports ARM processors.</p> <p>PyOCD stands out for its user-friendly approach compared to other On-Chip Debugging (OCD) tools like OpenOCD, despite being slightly limited in terms of the range of processors it supports.</p> <p>For the full documentation for PyOCD see https://pyocd.io/.</p>"},{"location":"user_guide/debugging/#installation","title":"Installation","text":"<p>To install PyOCD, run the following command in your terminal:</p> <pre><code>python3 -m pip install pyocd\n</code></pre>"},{"location":"user_guide/debugging/#connecting-a-debugger-to-your-device","title":"Connecting a Debugger to your Device","text":"<p>Connect the debugger (STLinkV2) to your MicroMod Carrier board using the STLink to SWD connector adapter. Before connecting and powering everything check that the the ribbon connector is connected to the port with the glowing LED. That is the correct connection. Using the incorrect connection could cause part damage.</p> <p>If you are using another type of device with different connections follow this guide. A connection to ground (<code>GND</code>) must be made between the debugger and the development board in order for the devices to communicate.</p> <p>Danger</p> <p>DOUBLE AND TRIPLE CHECK YOUR CONNECTIONS! Incorrect connects can result in breaking a board, debugger or possible your computer.</p> Connecting SWDConnecting JTAG <p>Connect jumpers from <code>GND</code>, <code>SWDIO</code> and <code>SWDCLK</code> to the pins on the board. If the board supports both <code>SWD</code> and <code>JTAG</code> like many arm cortex boards do, then connect the pins in the following way: <code>SWDIO</code> --&gt; <code>TMS</code> and <code>SWDCLK</code> --&gt; <code>TCK</code>.</p> <p>Connect jumpers from the <code>GND</code>, <code>TDI</code>, <code>TMS</code>, <code>TCK</code>, and <code>TDO</code> pins on the JTAG debugger to the headers on the development board of the same name.</p>"},{"location":"user_guide/debugging/#connecting-to-device-using-pyocd","title":"Connecting to device using PyOCD","text":"<p>The following commands will use <code>pyocd</code> and your debugger to connect to your target platform.</p> lpc40stm32f1 <pre><code>pyocd gdbserver --target=lpc4088 --persist\n</code></pre> <pre><code>pyocd gdbserver --target=stm32f103rc --persist\n</code></pre> <p>To find all of the available platforms use <code>pyocd list --targets</code>.</p>"},{"location":"user_guide/debugging/#using-arm-none-eabi-gdb","title":"Using arm-none-eabi-gdb","text":"<p><code>arm-none-eabi-gdb</code> is a version of GDB (GNU Debugger) configured for debugging Arm Cortex-M devices.</p> <p>To start a GDB debugging session, open an additional terminal or terminal window. Then execute the following command:</p> <pre><code>arm-none-eabi-gdb -ex \"target remote :3333\" -tui path/to/yourfile.elf\n</code></pre> <ul> <li><code>-tui</code>: GDB TUI provides a text window interface for debugging. To start GDB   in TUI mode, use the <code>-tui</code> option</li> <li><code>-ex \"target remote :3333\"</code>: <code>-ex</code> executes a GDB command. And the command   <code>target remote :3333</code> connects to a remote gdb server, in this case, the pyocd   server (with default port <code>:3333</code>).</li> </ul>"},{"location":"user_guide/debugging/#starting-the-debugging-process","title":"Starting the Debugging Process","text":"<p>Here is a cheat sheet for using GDB Cheat Sheet.</p> <p>A typical first breakpoint for a program is to set a breakpoint on main.</p> <pre><code>b main\n</code></pre> <p>Next you will want to reset the program back to the start and halt the CPU using the following command.</p> <pre><code>monitor reset halt\n</code></pre> <p>To begin running through the program use the <code>continue</code> or <code>c</code> command.</p> <pre><code>c\n</code></pre> <p>At this point you should see the source code of your <code>main.cpp</code> show up. Now you can step through your code and set breakpoints using <code>step</code>, <code>next</code>, <code>finish</code> and <code>continue</code>, <code>break</code>, etc.</p> <p>Typically you would use the <code>run</code> command to start the code. When performing firmware testing, the <code>run</code> command is not needed as the code is already \"running\" on the remote microcontroller.</p> <p>Info</p> <p>On boards with a factory bootloader, when you start debugging, you will notice that you cannot see the source code lines in the gdb shell. This is because the bootloader instructions are not associated with any addresses in your code, thus you will not see source code. This is fine. Continue with the guide. The LPC40xx family of microcontrollers has such a bootloader.</p>"},{"location":"user_guide/debugging/#stepping-through-code","title":"Stepping Through Code","text":"<p>Once in a GDB session, you can step through your code using the following commands:</p> <ul> <li><code>next</code> or <code>n</code>: Executes the next line in the source code. If the line contains   a function call, it treats the entire function as one instruction and executes   it in one go.</li> <li><code>step</code> or <code>s</code>: Executes the next line, but if it contains a function call,   <code>step</code> will go into that function so you can continue debugging inside it.</li> <li><code>finish</code>: Runs until the current function is finished.</li> <li><code>continue</code> or <code>c</code>: Continues execution until the next breakpoint or   watchpoint.</li> <li><code>until lineno</code>: Continues execution until a line number greater than the   current one is reached. Useful for loops.</li> </ul> <p>Remember that you can use the <code>help</code> command in GDB to get information about any other command.</p>"},{"location":"user_guide/debugging/#inspecting-variables-and-registers","title":"Inspecting Variables and Registers","text":"<p>You can inspect the state of your program by examining variables and registers:</p> <ul> <li><code>print variable</code> or <code>p variable</code>: Prints the current value of the specified   variable.</li> <li><code>info registers</code>: Shows the current state of all CPU registers.</li> <li><code>info register regname</code>: Shows the current state of a specific CPU register.</li> <li><code>print gpio_reg-&gt;CTRL</code>: Shows the value of a register</li> </ul> <p>Tip</p> <p>If you get an error like:</p> <pre><code>Cannot access memory at address ???\n</code></pre> <p>This happens because GDB is limiting access to memory that is known at link time and is apart of the binary's structure. But if a user wants to access peripheral memory not associated with RAM or Flash memory then they can execute this command:</p> <pre><code>set mem inaccessible-by-default off\n</code></pre>"},{"location":"user_guide/debugging/#setting-breakpoints-and-watchpoints","title":"Setting Breakpoints and Watchpoints","text":"<p>Breakpoints allow you to pause program execution at a particular point, and watchpoints let you pause execution whenever a particular variable changes:</p> <ul> <li><code>break function</code> or <code>b function</code>: Sets a breakpoint at the beginning of the   specified function.</li> <li><code>break filename:lineno</code> or <code>b filename:lineno</code>: Sets a breakpoint at a   specific line in a specific file.</li> <li><code>watch variable</code>: Sets a watchpoint on a variable. The program will stop   executing whenever the variable's value changes.</li> <li><code>info breakpoints</code>: Lists all the breakpoints that are currently set.</li> <li><code>delete n</code>: Deletes breakpoint number <code>n</code>. Use <code>info breakpoints</code> to see   breakpoint numbers.</li> <li><code>delete</code>: Deletes all breakpoints if used without a number.</li> </ul>"},{"location":"user_guide/debugging/#flashing-a-device-using-gdb","title":"Flashing a Device using GDB","text":"<p>In GDB, you can also use the <code>load</code> command to flash your device. The <code>load</code> command automatically uses the target specified when you started the GDB session.</p> <pre><code>(gdb) load\n</code></pre> <p>This command will load the program onto your device.</p> <p>You can build the elf file in another terminal, then run <code>load</code> again to update the program. It may or may not reset the core back to the start so <code>monitor reset halt</code> may be needed.</p>"},{"location":"user_guide/error_handling/","title":"\ud83e\udea4 Error Handling in libhal","text":"<p>libhal utilizes C++ exception handling for transmitting errors. C++ exceptions were chosen over other error handling mechanisms because they:</p> <ol> <li>Improve code performance by separating error handling code from normal    code, thus enhancing the performance of the normal code by reducing the    cost of calling functions that could fail.</li> <li>Make error handling easier by allowing the user to wrap multiple blocks of    code within a handler distinguished by the type/category.</li> <li>Reduce the binary size of libraries and applications by:</li> <li>Using a single algorithm to allocate, construct, and transport errors       and direct the CPU to the appropriate error handling code.</li> <li>Eliminating the need for functions to contain error return paths when       participating in error propagation.</li> <li>Providing an error path using unwind instructions, a compressed form of       machine instructions that simulate the epilog of a function, but without       the requirement to return objects on the stack.</li> <li>Although handler code can increase the code size compared to plain code    (if/else/switch), the number of error handling blocks (<code>catch</code> blocks) is    typically much smaller compared to the cost of a distributed error handling    approach (<code>result&lt;T, E&gt;</code>, returning error codes, <code>optional/nil/null</code>).</li> <li>Offer additional space in which they could be significantly improved upon    beyond their current performance.</li> </ol> <p>With that out of the way, let's delve into how libhal manages errors.</p>"},{"location":"user_guide/error_handling/#how-to-use-exceptions-in-c","title":"How to use exceptions in C++","text":"<p>Let's start with signaling an error. This can be done by writing the following bit of code:</p> <pre><code>void check_if_device_is_valid(/* ... */) {\n  constexpr hal::byte expected_id = 0xAD;\n\n  // Get ID info from device ...\n\n  if (expected_id != retrieved_id) {\n     throw hal::no_such_device(this, expected_id);\n  }\n}\n</code></pre> <p>And to catch the thrown error you do this following:</p> <pre><code>void bar() {\n  try {\n    check_if_device_is_valid(/* ... */);\n  } catch(const hal::no_such_device&amp; p_error) {\n    // do something using the error info.\n  }\n}\n</code></pre> <p>Note that this is a simplified example.</p> <p>The <code>throw</code> keyword functions similarly to other languages, where you can throw or raise an error object. This exits the function's scope without returning normally. This action causes the system to revert the CPU's state back to the state of the try scope. The exception mechanism then moves the CPU's program counter to the correct catch block based on the thrown type. In this case, since we threw <code>hal::no_such_device</code>, the catch block for that type will be selected. If no catch blocks are present with a valid error type in any scope from which the error object was thrown, then <code>std::terminate()</code> is called.</p> <p>Everything within the scope of the try block is no longer valid memory. The significance of this is that the exception unwinding mechanism can and must skip spending cycles on constructing and bubbling objects from a lower stack frame to a higher one. Since the thrown object is the only thing that escapes the scope, any information needed for error handling should be copied to the thrown object as it is being thrown.</p>"},{"location":"user_guide/error_handling/#halexception-hierarchy","title":"<code>hal::exception</code> hierarchy","text":"<p>libhal has a hierarchy of errors, which looks like the following:</p> <pre><code>hal::exception\n\u251c\u2500\u2500 hal::no_such_device\n\u2502   \u2514\u2500\u2500 hal::stm32f1::i2c_core_dump_io_error\n\u251c\u2500\u2500 hal::io_error\n\u2502   \u2514\u2500\u2500 hal::lpc40::i2c_core_dump_io_error\n\u251c\u2500\u2500 hal::timed_out\n\u251c\u2500\u2500 ...\n\u2514\u2500\u2500 hal::unknown\n</code></pre> <p><code>hal::exception</code> is the base exception for all libhal exceptions and is typically not thrown directly. Its descendants are thrown instead, most having a 1-to-1 correspondence with the enumerated constants in <code>std::errc</code>. <code>std::errc</code> follows the POSIX error codes, providing a reasonable approximation of the types of errors hardware might encounter. An exception to this rule is <code>hal::unknown</code>, which represents an unknown error, used when the exact error is undetermined. Such cases should be rare in code.</p> <p>To see the full list of exception types available, refer to the error API docs. It is important to consult this documentation to understand which exceptions should be thrown and under what circumstances they can be recovered from.</p>"},{"location":"user_guide/error_handling/#expectation-from-libhal-libraries","title":"Expectation from libhal libraries","text":"<p>libhal libraries and utilities are required to only use only the direct descendants of <code>hal::exception</code> or a more derived exception with additional information.</p> <p>Exceptions outside of the <code>hal::exception</code> hierarchy may still be thrown from a libhal library if it comes from a call to a user defined callback. The user is allowed to throw any types they wish, although care should be taken in choosing the types to be thrown. This is useful for application code that wants to bypass catch blocks provided by libhal libraries.</p>"},{"location":"user_guide/error_handling/#how-do-you-know-what-throws-what","title":"How Do You Know What Throws What?","text":"<p>C++ does not currently have a mechanism to inform the user at compile time if an uncaught exception will terminate your application. Therefore, to know what may be thrown from a function, you'll need to consult the API documentation for the function. All libhal interfaces have strict requirements for their implementations to throw very specific <code>hal::exception</code> derived types.</p>"},{"location":"user_guide/error_handling/#knowing-when-to-catch-an-error","title":"Knowing when to catch an error","text":"<p>First and foremost, accept that your application may encounter an exception that will terminate it. Plan with this possibility in mind. Use hal::set_exception to set the terminate handler function as needed for your application, such as saving state information and resetting the device.</p> <p>With this in mind, ONLY catch the errors you know how to handle. If you do not know how to handle an error, allow it to propagate to higher levels in the call chain. This gives higher-level code the opportunity to handle errors.</p> <p>Do not encase each function in a try/catch block, as this is detrimental to code size and degrades the performance of the unwind mechanism by providing it more scopes to search through.</p>"},{"location":"user_guide/error_handling/#when-to-catch-halexception","title":"When to catch <code>hal::exception</code>","text":"<p><code>hal::exception</code> should only be caught when code wants to swallow all possible exceptions from libhal OR when translating exceptions from C++ to a C API that needs an error code that roughly follows <code>std::errc</code>.</p> <pre><code>int c_callback() {\n  try {\n    foo();\n    bar();\n    baz();\n  } catch (const hal::exception&amp; p_error) {\n    return static_cast&lt;int&gt;(p_error.error_code());\n  }\n}\n</code></pre>"},{"location":"user_guide/error_handling/#using-halexceptioninstance","title":"Using <code>hal::exception::instance()</code>","text":"<pre><code>try {\n  read_timeout();\n  bandwidth_timeout();\n} catch (const hal::timed_out&amp; p_exception) {\n  if (&amp;read_timeout == p_exception.instance()) {\n    hal::print(console, \"X\");\n    read_complete = true;\n  }\n  // TODO: Replace this exceptional bandwidth timeout with a variant that\n  // simply returns if the timeout has occurred. This is not its intended\n  // purpose but does demonstrates proper usage of `p_exception.instance()`.\n  else if (&amp;bandwidth_timeout == p_exception.instance()) {\n    hal::print(console, \"\\n   +  |\");\n    bandwidth_timeout = hal::create_timeout(counter, graph_cutoff);\n  } else {\n    throw;\n  }\n}\n</code></pre> <p>In this case, <code>read_timeout</code> and <code>bandwidth_timeout</code> are callable objects that live in a scope above the try block allowing them to be modified and updated in the error handling block. Because both of these objects can throw an exception, we may want to know which one throw the exception. We can use the <code>instance()</code> function to get the address of the object that threw an exception. If the instance does not match anything in scope, then it may have been from an object that was lower in the stack and is no longer valid.</p> <p>Note the comment or <code>bandwidth_timeout</code>. <code>bandwidth_timeout</code> is apart of the normal control flow and should not be reporting errors to move along the normal control flow. <code>read_timeout</code> on the other hand does report an actual error in this context. This example is taken from <code>libhal-esp8266/demos/applications/at_benchmark.cpp</code>.</p> <p>Caution</p> <p>DO NOT USE <code>const_cast</code> and <code>reinterpret_cast</code> to FORCE an address from <code>instance()</code> into a pointer to some other type and then attempt to use it. This is strong undefined behavior. ONLY use the address returned from instance as a means to compare it to other objects.</p>"},{"location":"user_guide/error_handling/#why-you-shouldnt-throw-an-int-or-other-primitives","title":"Why you shouldn't throw an <code>int</code> or other primitives","text":"<p>Application callbacks are allowed to throw whatever type they wish although care should be taken to consider a good type to throw.</p> <p>Throwing <code>int</code> is generally a bad choice because it gives little to no information about what the kind of error is. And if such a choice was used, it probably means that the int encodes an error code, meaning many sections of code would need to catch it, check if its their error code, and rethrow it, if it is not the correct error code. This resulting in a large number of catch blocks.</p>"},{"location":"user_guide/fundamentals/","title":"\ud83e\uddf1 Fundamentals of libhal","text":"<p>libhal stands for \"Hardware Abstraction Layer Library\". The libhal library just contains a set of C++ interfaces for the various common hardware devices. If a developer wants to turn off and on an LED, then the user can simply construct a <code>hal::output_pin</code> and use the <code>level(bool)</code> API to turn the pin's voltage from high to low. The developer using that output pin does not need to know:</p> <ol> <li>How to power-on/enable the pin for the platform or device it comes from</li> <li>How to enable timing for the peripheral (if relevant)</li> <li>Which registers need to be modified to change the pin direction</li> <li>Which registers need to be modified to change the pin state</li> </ol> <p>All of the above in the list be taken care of by the driver implementation. This allows applications and driver implementations to be decoupled from each other, allowing them to follow the semantics of the interface. The application and drivers can simply use it as specified by the output pin API documentation.</p>"},{"location":"user_guide/fundamentals/#interfaces","title":"Interfaces","text":"<p>Interfaces are the basic building blocks of libhal and enable the flexibility needed to be portable. An interface is a set of required functions that an implementing class must adhere to. Any software that implements (inherits) an interface must provide implementations for each function in the interface, otherwise the compiler will generate a compiler error. The implementation must follow the rules of the interface as specified in the interface's API documentation. These API documentation represents the semantics and behavior of the driver.</p> <p>Lets consider an input pin, which is a pin on the controller that can be read by software. The state of the pin can be TRUE or FALSE, which corresponds to a HIGH or LOW voltage.</p> <pre><code>class input_pin\n{\npublic:\n  struct settings\n  {\n    pin_resistor resistor = pin_resistor::none;\n  };\n\n  void configure(settings const&amp; p_settings) { driver_configure(p_settings); }\n  [[nodiscard]] bool level() { return driver_level(); }\n\n  virtual ~input_pin() = default;\nprivate:\n  virtual void driver_configure(settings const&amp; p_settings) = 0;\n  virtual bool driver_level() = 0;\n};\n</code></pre> <p>As you can see there are two APIs, <code>configure</code> which is used to configure the pin and <code>level</code> which is used to read back the voltage level state of the pin.</p> <p>Why the private virtual functions?</p> <p>libhal uses the private virtual, public class function design pattern for inferfaces, because it allows us the capability to add supporting code before and after the virtual call. This can be used to fix bugs, issues, or remove undefined behavior for the virtual calls, for all callers without having to request that application or library developers update their code.</p> <p>One of the key advantages of using interfaces is the ability to write functions that can work with any implementation of an interface. This is done by writing functions that accept pointers or references to the base interface class.</p> <p>For example, you can pass a specific driver implementation to a function that takes a pointer or reference to the base class <code>input_pin</code>:</p> <pre><code>void process_pin(input_pin&amp; pin)\n{\n  pin.configure({ .resistor pin_resistor::pull_up });\n\n  if (pin.level()) {\n    // Do something when the pin is HIGH\n  } else {\n    // Do something when the pin is LOW\n  }\n}\n\n// Somewhere else in your code\nconcrete_input_pin my_pin; // This is your specific driver implementation\n// This works because concrete_input_pin inherits from input_pin\nprocess_pin(my_pin);\n</code></pre> <p>This is possible because <code>concrete_input_pin</code> inherits from <code>input_pin</code>, and C++ allows passing derived class objects to functions that accept base class pointers or references. This concept is known as polymorphism, and it allows your code to be more flexible and reusable.</p>"},{"location":"user_guide/fundamentals/#driver-types","title":"Driver Types","text":""},{"location":"user_guide/fundamentals/#peripheral-drivers","title":"Peripheral Drivers","text":"<p>Drivers for a platform that is embedded within the platform, system, development board, or operating system. For micro-controllers these peripherals  therefore cannot be removed from the chip and is generally fixed in number.</p> <ul> <li>output pin</li> <li>i2c</li> <li>can</li> <li>serial/uart</li> </ul>"},{"location":"user_guide/fundamentals/#device-drivers","title":"Device Drivers","text":"<p>Drivers for devices external to a platform. Device drivers have constructors accepting libhal interface implementations. In order to construct the device driver all of the interface requirements of the driver must be met, either by a peripheral driver or a device driver that is capable of generating additional drivers.</p> <ul> <li>temperature sensor</li> <li>motor controller</li> <li>smart servo</li> <li>gps</li> </ul>"},{"location":"user_guide/fundamentals/#soft-drivers","title":"Soft Drivers","text":"<p>Drivers that do not have any specific underlying hardware associated with them. They are used to emulate, give context to, or alter the behavior of a driver or interface implementation.</p> <ul> <li>bit bang i2c using two output pins (that are open drain capable)</li> <li>input pin inverter</li> <li>output pin inverter</li> <li>minimum speed i2c (a wrapper for i2c that ensures the i2c configuration   speed is the minimum required to work for all devices using it.)</li> </ul>"},{"location":"user_guide/fundamentals/#libhal-librariespackage-categories","title":"libhal libraries/package categories","text":"<p>libhal has many types of libraries. This is due to the wide range of useful types of libraries in embedded systems.</p>"},{"location":"user_guide/fundamentals/#compiler-package","title":"Compiler Package","text":"<p>A compiler package downloads and setups up a compiler for general use by an application. libhal's provides a compiler package for the ARM GNU toolchain which provides all of the GNU GCC compiler commands for building application, binaries and library files.</p>"},{"location":"user_guide/fundamentals/#platform-library","title":"Platform Library","text":"<p>Contain the drivers and APIs specific to a processor. For example, ARM Cortex M processors have a common way to manage interrupts, so that code should be put into the processor library. Almost all Cortex M processors have a SysTick Timer, so such a driver should exist in the processor library.</p> <p>Platform libraries also contain peripheral driver implementations as well as target specific APIs for operations such as DMA transfers, pin configuration and function selection, clock control, etc, for a specific family of devices.</p> <p>Peripherals are devices within a microcontroller or computer system that allows the controller:</p> <ol> <li>To interact with the world in a particular way such as:<ol> <li>output pin</li> <li>input pin</li> <li>i2c</li> <li>serial</li> <li>can</li> <li>usb</li> </ol> </li> <li>Interrupt the CPU when an event has occurred<ol> <li>timers</li> <li>interrupt pin</li> <li>watchdog</li> </ol> </li> <li>Perform work for the CPU/application<ol> <li>real time clocks</li> <li>crc generators</li> <li>random number generator</li> <li>display graphics accelerator</li> </ol> </li> </ol> <p>The hardware implementations of a peripheral in a controller is typically unique to that controller's device family. The peripheral drivers provide an abstraction to the peripheral hardware and allows easy control of the driver in code. Peripheral drivers are developed for peripheral devices that are expectation to be in all or a subset of devices within a device family.</p> <p>Platform drivers are the foundation of all libhal applications. These drivers provide a direct means to access hardware. They are used either directly by an application OR passed to another driver to perform some work. If you want to turn on an LED, you'll need to utilize an output pin. If you wanted to interact with a temperature sensor that communicates over i2c, then you'd need a peripheral driver that supports i2c. From the peripheral drivers, all other drivers can be constructed. The question then becomes, does the chip you want, have the peripherals you'd like to use for your application.</p> <p>Peripheral drivers typically do not take libhal interfaces as inputs.</p>"},{"location":"user_guide/fundamentals/#device-library","title":"Device Library","text":"<p>Device libraries containing drivers for specific hardware devices or modules, such as a sensors, displays, or a motor controllers. Device libraries require resources from the platform, typically peripheral drivers, memory (ram), and/or drivers that come from other device libraries. Device drivers are generally platform agnostic and should be usable on any system that can support their driver, memory, and performance requirements. You can generally tell something is a device driver if its constructor takes one or more libhal interfaces.</p>"},{"location":"user_guide/fundamentals/#soft-device-library","title":"Soft Device Library","text":"<p>Soft drivers are drivers that do not have any specific underlying hardware associated with them. They are used to emulate, give context to, or alter the behavior of interfaces. For a driver to be a soft driver it must implement or have a way to generate, construct or create implementations of hardware interfaces.</p> <p>For example, one could emulate i2c by using two output_pins set to the open drain configuration to enable bi-directional communication.</p> <p>Another example would be an input_pin inverter that takes a <code>hal::input_pin</code> and simply inverts the logic of the values read from the input pin to suite the needs of another library that expects the values to be a certain logic level.</p> <p>And finally, thread-safe variants of <code>hal::i2c</code> can be made by passing a <code>hal::i2c</code> and a lock to the thread safe i2c implementation and allowing that implementation to lock the i2c resource while a thread is using it.</p>"},{"location":"user_guide/fundamentals/#utility-library","title":"Utility Library","text":"<p>These libraries are purely software-based and do not directly interact with hardware. They provide useful utilities, data structures, algorithms, and other software components that can be used across different parts of an application. Examples might include an efficient circular buffer implementation, a data structure for facilitating cross-driver communication, or a driver that performs a specific algorithm on data. These libraries are platform-agnostic and can be used in any application that meets their requirements.</p>"},{"location":"user_guide/fundamentals/#3rd-party-library","title":"3rd Party library","text":"<p>3rd party libraries that make a compiled library available for libhal targets processors. Examples of this would be:</p> <ul> <li>freertos</li> <li>lwip</li> <li>Elm Chan's FatFS</li> </ul> <p>These are different from what is usually provided on the conan center which are header only libraries which can work anywhere so long as the APIs and constructs are also supported by the architecture and compiler. For example if a header only library uses the C++ <code>&lt;thread&gt;</code> APIs and the compiler and architecture doesn't have support for that, then a compiler or linker error will occur.</p>"},{"location":"user_guide/fundamentals/#rtos-library","title":"RTOS Library","text":"<p>RTOS stands for Real Time Operating System and using these libraries will enable multi-tasking and multi-threading capability to the application. libhal specific RTOS libraries typically provide helper objects and classes that support libhal interfaces and systems.</p>"},{"location":"user_guide/fundamentals/#process-libraries","title":"Process Libraries","text":"<p>Code that performs some work using a set of resources provided by the application. These aren't driver in that they use drivers to achieve a goal. Typically implemented as a function but could be an object as well.</p> <p>Some ideas for what this could be:</p> <ul> <li>Sensor fusion process that produces orientation information when supplied N   number of accelerometer, gyroscope, and produces accurate orientation   information.</li> <li>A servo process that takes a motor, a rotational sensor, and function that   can be called by the process to get its current rotational orientation.</li> </ul>"},{"location":"user_guide/fundamentals/#concrete-drivers","title":"Concrete Drivers","text":"<p>In libhal, not all drivers are designed to implement an interface. These drivers, referred to as \"Concrete Drivers\", are unique in that they typically do not contain virtual functions and cannot be passed in a generic form. Despite this, they play a crucial role in the library due to their specific functionality and support for certain hardware components.</p> <p>Concrete Drivers are fully realized classes that provide direct, specific functionality. They are designed to interact with a particular piece of hardware or perform a specific task, and their methods provide a direct interface to that hardware or task. Because they do not implement an interface, they cannot be used polymorphically like other drivers in libhal. However, their specificity allows them to provide robust, efficient, and direct control over their associated hardware.</p> <p>These drivers are particularly useful in scenarios where a specific piece of hardware or a specific task does not neatly fit into one of the existing libhal interfaces, or when the overhead of virtual functions is not desirable. Despite not conforming to a specific interface, Concrete Drivers adhere to the same design principles as other components of libhal, ensuring consistency and reliability across the library.</p> <p>In libhal, not all drivers are designed to implement an interface. These drivers, referred to as \"Concrete Drivers\", are unique in that they typically do not contain virtual functions and cannot be passed in a generic form. Despite this, they play a crucial role in the library due to their specific functionality and support for certain hardware components.</p> <p>Note that this isn't a distinct type outside of the list of Driver types mentioned above. Concrete drivers can be a peripheral, device and soft driver. They simply do not implement an interface.</p>"},{"location":"user_guide/fundamentals/#multi-interface-support","title":"Multi-Interface Support","text":"<p>Many concrete drivers have the capability to support multiple interfaces at once. For example, a driver for the RMD-X6 smart motor can act as a servo, a motor, a temperature sensor (for itself), a voltage sensor (for the bus it is connected to), a current sensor (for how much current it's consuming), and a rotation sensor (for its output shaft's position). To create these drivers from the concrete driver, an adaptor class must be used. These adaptor classes take a reference to the concrete class and use its methods in order to implement the interface APIs.</p> <p>Multi-inheritance MUST NEVER BE USED TO ACHIEVE THIS. This has to do with how multi-inheritance of polymorphic types effects the vtable of a type and how the interfaces put additional requirements on the exposed APIs of a clas.</p>"},{"location":"user_guide/fundamentals/#adaptor-factory-functions","title":"Adaptor Factory Functions","text":"<p>In libhal, there is a common language policy for adaptors. To create them you must call a factory function called <code>make_&lt;name of interface&gt;()</code> and it will return an <code>adaptor_object</code>. There is an overload for every driver that implements a particular interface. For example, in order to generate a servo from the RMD X6 smart actuator, it would look like this:</p> <pre><code>hal::rmd::drc my_smart_actuator(/* ... */);\nauto smart_servo_driver = make_servo(my_smart_servo);\n</code></pre> <p>This approach allows for a consistent and efficient way to create adaptors for various interfaces from a single concrete driver. It ensures that the concrete driver can be utilized to its full potential, providing access to all its capabilities through the appropriate interfaces.</p>"},{"location":"user_guide/interfaces/","title":"\ud83d\udd17 Interfaces in Software Development and libhal","text":"<p>In software development, an interface is a shared boundary across which two separate components of a computer program exchange information. The exchange can be between software, computer hardware, peripheral devices, humans, and combinations of these. Technically, it refers to a software component (a class, a module, etc.) that encapsulates a specific functionality and that can be used by other components.</p> <p>Interfaces work by specifying the methods that a class must implement, without including the implementation of the methods themselves. This allows different classes to implement the same interface in different ways, providing a level of abstraction between the interface and the implementation.</p> <p>In the context of libhal (Hardware Abstraction Layer Library), interfaces are used to define a standard way of interacting with different types of hardware. This makes the software portable because it can interact with the hardware through the interface, without needing to know the specifics of how the hardware is implemented. This means that if the underlying hardware changes, only the implementation of the interface needs to change, not the software that uses it.</p>"},{"location":"user_guide/interfaces/#driver-types-in-libhal","title":"Driver Types in libhal","text":""},{"location":"user_guide/interfaces/#digital","title":"Digital","text":"Input PinOutput PinInterrupt Pin <p>See API: <code>hal::input_pin</code></p> <p>The Input Pin interface (<code>hal::input_pin</code>) in libhal is used for reading the state of a digital input pin. This is useful in situations where you need to determine if the voltage on a pin is HIGH or LOW.</p> <p>In the libhal library, the Input Pin interface provides methods to configure the input pin according to the settings supplied and to read the state of the input pin.</p> <p>See API: <code>hal::output_pin</code></p> <p>The Output Pin interface in libhal is used for controlling the state of a digital output pin. This is useful in situations where you need to send a control signal or turn on or off an LED.</p> <p>In the libhal library, the Output Pin interface provides methods to configure the output pin according to the settings supplied, to set the state of the pin, and to read the current state of the output pin.</p> <p>See API: <code>hal::interrupt_pin</code></p> <p>The Interrupt Pin interface in libhal is used for automatically calling a function when a pin's state has transitioned. This is useful in situations where you need to respond to changes in the state of a pin.</p> <p>In the libhal library, the Interrupt Pin interface provides methods to configure the interrupt pin according to the settings supplied and to set the callback for when the interrupt occurs.</p>"},{"location":"user_guide/interfaces/#analog","title":"Analog","text":"ADC (Analog-to-Digital Converter)DAC (Digital-to-Analog Converter)PWM (Pulse Width Modulation) <p>See API: <code>hal::adc</code></p> <p>The ADC interface in libhal is used to convert an analog signal into a digital one. This is useful in situations where the hardware device is producing an analog signal, such as a sensor reading, but the software works with digital values.</p> <p>In the libhal library, the ADC interface provides methods to read the voltage from the ADC as a percentage of the reference voltage.</p> <p>See API: <code>hal::dac</code></p> <p>The DAC interface in libhal is used to convert a digital signal into an analog one. This is useful in situations where the software is producing digital values, but the hardware device requires an analog signal.</p> <p>In the libhal library, the DAC interface provides methods to write a voltage to the DAC, as a percentage of the reference voltage.</p> <p>See API: <code>hal::pwm</code></p> <p>The PWM interface in libhal is used to control the waveform generation of a square wave and its properties such as frequency and duty cycle. PWM is used for power control like motor control, lighting, transmitting signals to servos, sending telemetry and much more.</p> <p>In the libhal library, the PWM interface provides methods to set the PWM waveform frequency and duty cycle.</p>"},{"location":"user_guide/interfaces/#time-timers","title":"Time &amp; Timers","text":"TimerSteady Clock <p>See API: <code>hal::timer</code></p> <p>The Timer interface in libhal is used for scheduling events to occur after a specified amount of time. This is useful in situations where you need to perform an action after a certain amount of time has passed.</p> <p>In the libhal library, the Timer interface provides methods to check if the timer is running, cancel a scheduled event, and schedule a new event.</p> <p>See API: <code>hal::steady_clock</code></p> <p>The Steady Clock interface in libhal is used for a steady clock mechanism. This clock is steady meaning that subsequent calls to get the uptime of this clock cannot decrease as physical time moves forward and the time between ticks of this clock are constant and defined by the clock's frequency.</p> <p>In the libhal library, the Steady Clock interface provides methods to get the operating frequency of the steady clock and to get the current value of the steady clock.</p> <p>This completes the descriptions for all the interfaces in the libhal library. Each of these interfaces provides a way to interact with different types of hardware in a consistent and portable way, making it easier to write embedded software that can run on different platforms.</p>"},{"location":"user_guide/interfaces/#serial-communication-protocols","title":"Serial Communication Protocols","text":"SPI (Serial Peripheral Interface)I2C (Inter-Integrated Circuit)SerialCAN (Controller Area Network) <p>See API: <code>hal::spi</code></p> <p>The SPI interface in libhal is used for communication over a Serial Peripheral Interface (SPI). This is a synchronous serial communication interface specification used for short-distance communication, primarily in embedded systems.</p> <p>In the libhal library, the SPI interface provides methods to configure the SPI bus and perform an SPI transaction.</p> <p>See API: <code>hal::i2c</code></p> <p>The I2C interface in libhal is used for communication over an Inter-Integrated Circuit (I2C) bus. This is a multi-master, multi-slave, packet switched, single-ended, serial computer bus invented by Philips Semiconductor.</p> <p>In the libhal library, the I2C interface provides methods to configure the I2C bus and perform an I2C transaction.</p> <p>See API: <code>hal::serial</code></p> <p>The Serial interface in libhal is used for hardware that implements a serial protocol like UART, RS232, RS485, and others that use a similar communication protocol but may use different voltage schemes.</p> <p>In the libhal library, the Serial interface provides methods to configure the serial to match the settings supplied, to write data to the transmitter line of the serial port, to copy bytes from the working buffer into the passed buffer, and to flush the working buffer.</p> <p>Unfortunately, I encountered an error while trying to access the Steady Clock interface file in the libhal repository. I'll try again to retrieve its content.</p> <p>See API: <code>hal::can</code></p> <p>The CAN interface in libhal is used for communication over a Controller Area Network (CAN bus). This is a robust vehicle bus standard designed to allow microcontrollers and devices to communicate with each other's applications without a host computer.</p> <p>In the libhal library, the CAN interface provides methods to configure the CAN bus, send a CAN message, and set a message reception handler.</p>"},{"location":"user_guide/interfaces/#actuators","title":"Actuators","text":"MotorServo <p>See API: <code>hal::motor</code></p> <p>The Motor interface in libhal is used for controlling an open loop rotational actuator. This can represent a variety of things such as a driver for a motor controller IC like the DRV8801, a driver for a motor with an integrated controller &amp; serial interface, a unidirectional motor controlled by a single transistor, or a servo with open loop motor control.</p> <p>In the libhal library, the Motor driver provides methods to apply power to the motor. The power applied is a percentage of the total available power.</p> <p>See API: <code>hal::servo</code></p> <p>The Servo interface in libhal is used for controlling a closed loop position controlled rotational actuator. Servos are devices that can rotate to a specified position.</p> <p>In the libhal library, the Servo interface provides methods to set the position of the servo's output shaft.</p>"},{"location":"user_guide/interfaces/#sensors","title":"Sensors","text":"Temperature SensorAccelerometerGyroscopeMagnetometerDistance SensorRotation Sensor <p>See API: <code>hal::temperature_sensor</code></p> <p>The Temperature Sensor interface in libhal is used for reading the current temperature measured by a device. This is useful in situations where you need to monitor the temperature of a device or environment.</p> <p>In the libhal library, the Temperature Sensor interface provides a method to read the current temperature.</p> <p>See API: <code>hal::accelerometer</code></p> <p>The Accelerometer interface in libhal is used for sensing acceleration. Accelerometers are devices that measure the rate of change of velocity with respect to time (acceleration).</p> <p>In the libhal library, the Accelerometer interface provides methods to read the acceleration sensed by the device in the X, Y, and Z axes.</p> <p>Accelerometers are commonly used to determine orientation or tilt of an object.</p> <p>See API: <code>hal::gyroscope</code></p> <p>The Gyroscope interface in libhal is used for sensing angular velocity. Gyroscopes are devices that measure the rotational speed around an axis.</p> <p>In the libhal library, the Gyroscope interface provides methods to read the angular velocity sensed by the device in the X, Y, and Z axes.</p> <p>See API: <code>hal::magnetometer</code></p> <p>The Magnetometer interface in libhal is used for sensing magnetic field strength. Magnetometers are devices that measure the strength and direction of a magnetic field.</p> <p>In the libhal library, the Magnetometer interface provides methods to read the magnetic field strength sensed by the device in the X, Y, and Z axes.</p> <p>Such devices are commonly used as a compass in order to provide heading information to a device.</p> <p>See API: <code>hal::distance_sensor</code></p> <p>The Distance Sensor interface in libhal is used for sensing linear distance. Distance sensors can be used in a variety of applications, such as measuring the distance to an object or determining the position of an object.</p> <p>In</p> <p>the libhal library, the Distance Sensor interface provides methods to read the current distance measured by the device.</p> <p>See API: <code>hal::rotation_sensor</code></p> <p>The Rotation Sensor interface in libhal is used for sensing a single axis of rotation. Rotation sensors can be used in a variety of applications, such as measuring the rotation to an object or determining the angular position of an object.</p> <p>In the libhal library, the Rotation Sensor interface provides methods to read the current angle, in degrees, measured by the device.</p> \u23f3 Current Sensor\u23f3 Voltage Sensor\u23f3 GPS <p>API not available yet</p> <p>A Current Sensor driver in libhal would be used for sensing electrical current. Current sensors are devices that detect the current of current flowing through a circuit.</p> <p>In the libhal library, the Current Sensor interface provides methods to read the current as a unit of <code>amperes</code>.</p> <p>API not available yet</p> <p>A Voltage Sensor driver in libhal would be used for sensing electrical voltage. Voltage sensors are devices that can measure the voltage potential difference between two points in an electrical circuit. When available, the Voltage Sensor driver would provide methods to read the voltage sensed by the device.</p> <p>In the libhal library, the Voltage Sensor interface provides methods to read the current as a unit of <code>volts</code>.</p> <p>API not available yet</p> <p>A GPS (Global Positioning System) driver in libhal would be used for receiving and interpreting GPS signals, which provide geolocation and time information to a GPS receiver anywhere on or near the Earth. When available, the GPS driver would provide methods to read the current location, speed, time, and other relevant data from the GPS signals.</p> <p>In the libhal library, the GPS interface provides methods to read location in longitude and latitude, get the current time, and get velocity.</p> <p>NOTE: that more investigation is needed to determine what fields make sense for this sensor and if it should be broken up into multiple interfaces like <code>hal::geolocation</code>, <code>hal::heading</code>, <code>hal::clock</code> and <code>hal::velocity</code>.</p>"},{"location":"user_guide/interfaces/#the-myth-about-virtual-understanding-dynamic-polymorphism-in-c","title":"The Myth about Virtual: Understanding Dynamic Polymorphism in C++","text":"<p>There's a common misconception in the C++ community that dynamic polymorphism inherently requires dynamic memory (heap memory), and that it's slower or more memory-intensive than other forms of polymorphism. This is not necessarily true. Let's debunk these myths.</p>"},{"location":"user_guide/interfaces/#dynamic-polymorphism-and-dynamic-memory","title":"Dynamic Polymorphism and Dynamic Memory","text":"<p>Dynamic polymorphism in C++ is achieved through virtual functions, which allow us to override functions in derived classes. This provides a way to use a base class pointer or reference to call the appropriate function based on the actual object type at runtime.</p> <p>While it's true that dynamic memory can be used in conjunction with dynamic polymorphism (for instance, when creating objects of derived classes and storing them in base class pointers), it's not a requirement. You can have dynamic polymorphism without dynamic memory.</p> <p>Consider a scenario where you have a base class <code>Base</code> and a derived class <code>Derived</code>. If you have a function that takes a reference to <code>Base</code>, you can pass an instance of <code>Derived</code> to that function without needing to allocate <code>Derived</code> on the heap:</p> <pre><code>void someFunction(Base&amp; baseRef) {\n    baseRef.someVirtualFunction();\n}\n\nDerived derived;\nsomeFunction(derived);  // No dynamic memory involved\n</code></pre> <p>In this case, <code>someFunction</code> will call the correct version of <code>someVirtualFunction</code> based on the actual type of the object, even though it's passed as a reference to <code>Base</code>. This is dynamic polymorphism in action, without any dynamic memory.</p>"},{"location":"user_guide/interfaces/#performance-of-dynamic-polymorphism","title":"Performance of Dynamic Polymorphism","text":"<p>Another myth is that dynamic polymorphism is slower than other forms of polymorphism, such as using a struct with function pointers (akin to C-style interfaces). In reality, the performance difference is negligible in most cases.</p> <p>When a virtual function is called, the compiler needs to look up the function address in the virtual table (vtable) of the object. This is essentially a pointer dereference, which is the same operation needed to call a function through a function pointer in a struct. Therefore, the performance of these two approaches is comparable.</p>"},{"location":"user_guide/interfaces/#memory-overhead-of-virtual-polymorphism","title":"Memory Overhead of Virtual Polymorphism","text":"<p>The memory overhead of dynamic polymorphism is also often overstated. Each class with virtual functions has a vtable, which is essentially a static array of function pointers. This vtable is shared among all instances of the class, so it doesn't increase the per-instance memory overhead.</p> <p>The vtable does increase the size of the binary, but the increase is usually small. Each vtable entry is just a function pointer. For a class hierarchy with a reasonable number of virtual functions, this overhead is typically negligible.</p> <p>In addition to the function pointers, the vtable contains two more pointers: one for the parent class's vtable (for supporting inheritance) and one for Run-Time Type Information (RTTI, used for <code>dynamic_cast</code> and <code>typeid</code>). These are fixed overheads per class, not per object.</p> <p>In conclusion, while dynamic polymorphism in C++ does have some overhead, it's often smaller than people think. It doesn't inherently require dynamic memory, its performance is comparable to other forms of polymorphism, and its memory overhead is typically small. Therefore, it's a powerful tool for creating flexible and reusable code in C++.</p>"},{"location":"user_guide/policy/","title":"\u2696\ufe0f Policies &amp; FAQ","text":""},{"location":"user_guide/policy/#1-ensuring-consistency-across-platforms","title":"1. Ensuring Consistency Across Platforms","text":"<p>To maintain a consistent interface across platforms, libhal adopts:</p> <ol> <li>Clearly articulated rules and interface API documentation. This ensures every    potential input produces a predictable behavior.</li> <li>Testing mechanisms that ensure adherence to these standards.</li> </ol> <p>While libhal covers the documentation aspect, our CI integration doesn't yet encompass all testing facets, simulated or real-world. We are in the process of designing a compliance test suitable both for device testing and CI inclusion. Presently, the onus is on manual testing and meticulous inspection.</p> <p>Regarding unit tests: Although beneficial for purely software libraries, they're not always feasible for embedded systems. Once you mock components like i2c or input pins, the actual device testing veers towards simulation. This method is viable post verifying the device compatibility, solidifying the code behavior through unit tests. High-level conceptual and application codes can harness such tests, but unit testing often misaligns with low-level drivers.</p>"},{"location":"user_guide/policy/#2-driver-development-in-libhal","title":"2. Driver Development in libhal","text":"<p>How are these drivers created? Do new products gain immediate support?</p> <p>Our developers craft code by hand. Fully automated firmware driver solutions either fall short on efficiency or fail to span multiple devices. However, for devices adhering to standards like NMEA or JEDEC, automation holds potential. We're also considering tools that process SVD files into bit mask ranges, assuming no licensing complications arise.</p>"},{"location":"user_guide/policy/#3-oems-stance-on-libhal-software","title":"3. OEM's Stance on libhal Software","text":"<p>Does libhal have defenses against potential vendor objections?</p> <p>Using OEM-developed SDKs can be tricky due to restrictive licensing. For instance, SDKs from NXP or STM mandate their code only run on their specific devices. Some chips might mirror the architecture of another, but licensing can inhibit cross-utilization.</p> <p>Our safeguard? Any software we integrate is crafted by our engineers, strictly based on publicly accessible OEM manuals. We're mindful of potential exceptions and will handle them case-by-case.</p>"},{"location":"user_guide/policy/#4-vendor-sdk-utilization-in-libhal","title":"4. Vendor SDK Utilization in libhal","text":"<p>How does libhal tackle licensed APIs? What does it mean for the end developer?</p> <p>Currently, libhal steers clear of SDKs with confining licenses or those misaligned with Apache 2.0 or its equivalents. This includes licenses from NXP and STM. However, SDKs from Espressif Systems (with Apache 2.0) and Pico SDK are potentially usable so long as they reach our quality bar.</p>"},{"location":"user_guide/policy/#5-dealing-with-devices-lacking-public-manuals","title":"5. Dealing with Devices Lacking Public Manuals","text":"<p>Devices without public user manuals will not get a libhal library. Here's why:</p> <ol> <li>It risks unintentional exposure of proprietary device information.</li> <li>Without a manual, the code operates like a black box, turning debugging into    a reverse-engineering puzzle.</li> </ol> <p>We can craft drivers for such devices, but their source code would remain confidential. The libhal organization may perform such work on a contract basis but such work would not make it to the open source ecosystem.</p>"},{"location":"user_guide/setup_vscode/","title":"Setting up VSCode w/ <code>clangd</code>","text":"<p>Most of our users use VSCode so we made a guide for them. These guidelines should also work for non-vscode users as well.</p> <p>Info</p> <p>The default \"C/C++\" extension by VSCode is nice that it can figure a ton   of things out about your system automatically. But the way we write code   for <code>libhal</code> using <code>conan</code> makes the extension difficult and slow to use.   This is due to the fact that we need to point the extension to the   <code>.conan2/p/</code> (conan 2 package directory). Because that directory could   have a large number of files and multiple version of the same project, it   tends to get confused, stop working, or get very slow. We recommend   <code>clangd</code> because it is fast, helpful, and easy to use.</p>"},{"location":"user_guide/setup_vscode/#setup-steps","title":"Setup Steps","text":"<ol> <li>Install VSCode if you don't already have    it installed.</li> <li>Go the the \"Extensions\" section on the left side bar. Hover over the icons    to get their name.</li> <li>Search for \"C/C++\" and disable the extension if it is already installed and    enabled.</li> <li>Search for the extension <code>clangd</code> and install the extension.</li> <li>Install <code>clang</code><ol> <li>Ubuntu/Debian: <code>sudo apt install clang</code></li> <li>MacOS: <code>brew install llvm</code></li> <li>Windows: <code>choco install llvm</code></li> </ol> </li> <li>Add <code>--query-driver=**/arm-none-eabi-g++</code> (for Linux &amp; Mac) or    <code>--query-driver=**/arm-none-eabi-g++.exe</code> (for Windows) to the clangd command    arguments in the clangd settings.<ol> <li>Go the the extensions page</li> <li>Find clangd and press the GEAR icon and open up settings.</li> <li>Find the settings <code>clangd: Arguments</code> and add the above code there. It is    comma delimitated so you can add additional compiler patterns as well.</li> </ol> </li> </ol>"},{"location":"user_guide/setup_vscode/#how-clangd-works","title":"How <code>clangd</code> works","text":"<p>You are almost done, but we need to discuss what is needed to make <code>clangd</code> work. A workspace will need a <code>compile_commands.json</code> file to be present in your root directory or to use a <code>.clangd</code> file at the root of the repo that configures where to look for the <code>.json</code> file. <code>compile_commands.json</code> tells <code>clangd</code> what commands you are using in order to determine exactly how your files are built and what commands are used to build them, which provides the following benefits:</p> <ol> <li>More accurate warnings and error messages in the IDE</li> <li>Faster response time because only the necessary includes for the specific    version you are targeted will be used in the evaluation.</li> </ol>"},{"location":"user_guide/setup_vscode/#enabling-clangd","title":"Enabling <code>clangd</code>","text":""},{"location":"user_guide/setup_vscode/#for-a-libhal-library-projects","title":"For a libhal library projects","text":"<p>If you are contributing to libhal project/repo, then those libraries and demos will already be using <code>libhal-cmake-util/[^4.0.5]</code> which will automatically enable the generation of a <code>compile_commands.json</code> file. To get this file, run:</p> <pre><code>conan build .\n</code></pre> <p>And it will be generated.</p> <p>If you are attempting to do with is a demo or an application you will need to specify the platform and compiler like usual.</p> <pre><code>conan build . -pr lpc4078 -pr arm-gcc-12.3\n</code></pre>"},{"location":"user_guide/setup_vscode/#for-your-own-project","title":"For your own project","text":"<p>You can either add a <code>self.requires(\"libhal-cmake-util/[^4.0.5]\")</code> to your project or add the following lines to your <code>CMakeLists.txt</code>.</p> <pre><code># Generate compile commands for anyone using our libraries.\nset(CMAKE_EXPORT_COMPILE_COMMANDS ON)\n\n# Always run this custom target by making it depend on ALL\nadd_custom_target(copy_compile_commands ALL\n    COMMAND ${CMAKE_COMMAND} -E copy_if_different\n    ${CMAKE_BINARY_DIR}/compile_commands.json\n    ${CMAKE_SOURCE_DIR}/compile_commands.json\n    DEPENDS ${CMAKE_BINARY_DIR}/compile_commands.json)\n</code></pre> <p>Now run <code>conan build .</code> (where <code>.</code> is the path to your project or library) and it should generate the <code>compile_commands.json</code> file.</p> <p>Ensure that you include the necessary profiles added to the build.</p> <pre><code>conan build . -pr stm32f103 -pr arm-gcc-12.3\n</code></pre>"},{"location":"user_guide/setup_vscode/#refreshing-the-lsp","title":"Refreshing the LSP","text":"<p>Now that you should have your <code>compile_commands.json</code> in the right location, you just need to refresh your LSP.</p> <ol> <li>In VSCode Press: <code>\u2318+shift+P</code> on Mac or <code>Ctrl+Shift+P</code> on everything else.</li> <li>Select the following command: <code>clangd: restart language server</code></li> </ol> <p>Now your LSP should be active and your C++ files should be able to find your includes as well as infer the types of your objects.</p>"}]}